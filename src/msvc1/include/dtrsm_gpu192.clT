static const char * dtrsm_gpu192_kernels = "\
\n\
//only supports upper triangle matrix for now\n\
\n\
#define BLOCK_SIZE 12 // inner blocking size, <=32\n\
#define NB 192        // outer blocking size, >BLOCK_SIZE\n\
\n\
#define ZERO              ( 0.0)\n\
#define ONE               ( 1.0)\n\
\n\
#ifdef DOUBLE_PRECISION\n\
#ifdef cl_khr_fp64\n\
#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n\
#else\n\
#pragma OPENCL EXTENSION cl_amd_fp64 : enable\n\
#endif\n\
#endif\n\
\n\
__kernel void DIAG_DTRTRI_KERNEL_UPPER(int  isDiagUnit, \n\
                       __global double const * restrict A,\n\
                                       uint offA,\n\
                       __global double *d_dinvA,\n\
                       uint lda,\n\
                                       uint na)\n\
{\n\
\n\
  int i, j;\n\
  double Ystx = 0;\n\
  __local double *y = 0;\n\
  double switcher;\n\
  double neg_switcher;\n\
\n\
  // Thread index\n\
  int tx = get_local_id(0);\n\
\n\
  // Thread index\n\
  int gx = get_global_id(0);\n\
\n\
  // Block index\n\
  int bx = get_group_id(0);\n\
\n\
  A = A + offA;\n\
\n\
  __global const double *Aoff = A + bx*lda*BLOCK_SIZE + bx*BLOCK_SIZE;\n\
  int NumBLperNB = NB/BLOCK_SIZE;\n\
  d_dinvA += bx/NumBLperNB*NB*NB + (bx % NumBLperNB)*(NB*BLOCK_SIZE + BLOCK_SIZE);\n\
\n\
  __local double Bs[BLOCK_SIZE*BLOCK_SIZE];\n\
  __local double workspace[BLOCK_SIZE];    // workspace used to store the current working column\n\
\n\
"
"\
  // load A\n\
  #pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    {\n\
      if(tx <= i && i+bx*BLOCK_SIZE < na )\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = *(Aoff+i*lda+tx);    \n\
        }\n\
      else\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = ZERO; \n\
        }\n\
    } \n\
  // read in the whole square block of my A and zero out the non data triangular\n\
 \n\
  // Synchronize to make sure the matrices are loaded\n\
  //__syncthreads(); \n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  // solve the diagonals\n\
\n\
  if(isDiagUnit == 1)\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;\n\
    }\n\
  else\n\
    {\n\
      if( Bs[tx*BLOCK_SIZE+tx] == ZERO )\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;  \n\
    }\n\
      else\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE / ( Bs[tx*BLOCK_SIZE+tx]) ;\n\
    }      \n\
    }\n\
\n\
\n\
  /* the upper case */\n\
  for( i=0; i < BLOCK_SIZE; i++ ) {\n\
    Ystx =  ZERO;\n\
    if( tx < i)\n\
      {\n\
    switcher = ONE;\n\
      }\n\
    else\n\
      {\n\
    switcher = ZERO;\n\
      }\n\
\n\
"
"\
    //dtrmv\n\
    workspace[tx] = *(Bs+i*BLOCK_SIZE+tx);\n\
    y = Bs+i*BLOCK_SIZE;\n\
\n\
    #pragma unroll\n\
    //for( j=tx; j < i; j++ )\n\
    for( j=0; j < i; j++ )\n\
      Ystx += switcher * (*(Bs+j*BLOCK_SIZE+tx)*workspace[j]);\n\
\n\
    //sscal\n\
    // if (tx != i) y[tx]=switcher*Ystx*(-Bs[i*BLOCK_SIZE+i]);\n\
\n\
    if( tx != i)\n\
      {\n\
    switcher = ONE;\n\
    neg_switcher =  ZERO;\n\
      }\n\
    else\n\
      {\n\
    switcher = ZERO;\n\
    neg_switcher =  ONE;\n\
      }\n\
\n\
    y[tx] = switcher *Ystx*(-Bs[i*BLOCK_SIZE+i])+neg_switcher*y[tx];\n\
\n\
    // __syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
  }\n\
\n\
  // write back A\n\
#pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    *(d_dinvA+i*NB+tx) = Bs[i*BLOCK_SIZE+tx];\n\
\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 * 12 to 24\n\
 */\n\
__kernel void \n\
TRIPLE_DGEMM_UPDATE_12_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, uint lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 12 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 96 this is 4 for 192 this is 8\n\
\n\
"
"\
    //Work group size is [12]\n\
    //global work size is [96*number of blocks]\n\
    //each work item in each work group is responsible for every element in that row\n\
    //each work group is responsible for one gemm;\\n\
\n\
\n\
    ////////////// A12*invA22\n\
    const uint gidx = get_group_id(0);\n\
    const uint idx = get_local_id(0);\n\
\n\
    const uint page = gidx % npages;\n\
    const uint page_block = page/8;//8 pages per page block\n\
    const uint page_index_in_block = page%8;\n\
    \n\
    \n\
    __global double *B, *C;\n\
    __local double lA[12][12];\n\
    __local double lB[12][12];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide A12 location for each page\n\
    Ain = Ain + offAin;\n\
    Ain += (page*blk*2 + blk) * lda + page * 2 * blk;\n\
    \n\
    //decide invA22 (B) location for each page\n\
    B = d_dinvA + page_block*NB*NB + (page_index_in_block*blk*2 + blk) * NB + page_index_in_block * 2 * blk + blk;\n\
    \n\
    //decide invA12 location for each page\n\
    C = d_dinvA + page_block*NB*NB + (page_index_in_block*blk*2 + blk) * NB + page_index_in_block * 2 * blk;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    lA[idx][0] = Ain[idx];\n\
    lA[idx][1] = Ain[idx + lda];\n\
    lA[idx][2] = Ain[idx + lda*2];\n\
    lA[idx][3] = Ain[idx + lda*3];\n\
    lA[idx][4] = Ain[idx + lda*4];\n\
    lA[idx][5] = Ain[idx + lda*5];\n\
    lA[idx][6] = Ain[idx + lda*6];\n\
    lA[idx][7] = Ain[idx + lda*7];\n\
    lA[idx][8] = Ain[idx + lda*8];\n\
    lA[idx][9] = Ain[idx + lda*9];\n\
    lA[idx][10] = Ain[idx + lda*10];\n\
    lA[idx][11] = Ain[idx + lda*11];\n\
    \n\
    lB[idx][0] = B[idx];\n\
    lB[idx][1] = B[idx + NB];\n\
    lB[idx][2] = B[idx + NB*2];\n\
    lB[idx][3] = B[idx + NB*3];\n\
    lB[idx][4] = B[idx + NB*4];\n\
    lB[idx][5] = B[idx + NB*5];\n\
"
"\
    lB[idx][6] = B[idx + NB*6];\n\
    lB[idx][7] = B[idx + NB*7];\n\
    lB[idx][8] = B[idx + NB*8];\n\
    lB[idx][9] = B[idx + NB*9];\n\
    lB[idx][10] = B[idx + NB*10];\n\
    lB[idx][11] = B[idx + NB*11];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    //do math\n\
    \n\
    uint i = 0;\n\
    \n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11],privateC[11]); \n\
        //mem_fence(CLK_LOCAL_MEM_FENCE);\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
    i = 0;\n\
    do{\n\
        C[NB*i+idx] = privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
    ////////////// -invA11*invA12\n\
    barrier(CLK_GLOBAL_MEM_FENCE);\n\
    //A is moving to invA11\n\
    __global double *A;\n\
    A = d_dinvA + page_block*NB*NB + ( (page%4)*blk*2 ) * NB + (page%4) * 2 * blk;\n\
    //both B and C are pointing at invA12\n\
    B = C;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    lA[idx][0] = A[idx];\n\
    lA[idx][1] = A[idx + NB];\n\
    lA[idx][2] = A[idx + NB*2];\n\
    lA[idx][3] = A[idx + NB*3];\n\
    lA[idx][4] = A[idx + NB*4];\n\
    lA[idx][5] = A[idx + NB*5];\n\
"
"\
    lA[idx][6] = A[idx + NB*6];\n\
    lA[idx][7] = A[idx + NB*7];\n\
    lA[idx][8] = A[idx + NB*8];\n\
    lA[idx][9] = A[idx + NB*9];\n\
    lA[idx][10] = A[idx + NB*10];\n\
    lA[idx][11] = A[idx + NB*11];\n\
    \n\
    lB[idx][0] = B[idx];\n\
    lB[idx][1] = B[idx + NB];\n\
    lB[idx][2] = B[idx + NB*2];\n\
    lB[idx][3] = B[idx + NB*3];\n\
    lB[idx][4] = B[idx + NB*4];\n\
    lB[idx][5] = B[idx + NB*5];\n\
    lB[idx][6] = B[idx + NB*6];\n\
    lB[idx][7] = B[idx + NB*7];\n\
    lB[idx][8] = B[idx + NB*8];\n\
    lB[idx][9] = B[idx + NB*9];\n\
    lB[idx][10] = B[idx + NB*10];\n\
    lB[idx][11] = B[idx + NB*11];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    //do math\n\
    \n\
    i = 0;\n\
    privateC[0] = 0;    \n\
    privateC[1] = 0;\n\
    privateC[2] = 0;\n\
    privateC[3] = 0;\n\
    privateC[4] = 0;\n\
    privateC[5] = 0;\n\
    privateC[6] = 0;\n\
    privateC[7] = 0;\n\
    privateC[8] = 0;\n\
    privateC[9] = 0;\n\
    privateC[10] = 0;\n\
    privateC[11] = 0;\n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11],privateC[11]); \n\
        //mem_fence(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        i = i + 1;\n\
    }while(i < 12);\n\
\n\
    i = 0;\n\
    do{\n\
        C[NB*i+idx] = -1*privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
}\n\
\n\
__kernel void \n\
TRIPLE_DGEMM_UPDATE_24_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, uint lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 24 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 96 this is 2 for 192 this is 4\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [96*number of blocks, 2]\n\
    //each work item in each work group is responsible for 12 elements (half) in that row\n\
    //each work group is responsible for one gemm;\n\
\n\
\n\
    ////////////// A12*invA22\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
\n\
    const uint page = gidx % npages;//0-3 for 192; 0-1 for 96\n\
    const uint page_block = page/4;//4 pages per page block\n\
\n\
    \n\
    \n\
    __global double *B, *C;\n\
    __local double lA[24][24];\n\
    __local double lB[24][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide A12 location for each page\n\
    Ain = Ain + offAin;\n\
    Ain += (page*blk*2 + blk) * lda + page * 2 * blk;\n\
    \n\
    //decide invA22 (B) location for each page\n\
    B = d_dinvA + page_block*NB*NB + ((page%4)*blk*2 + blk) * NB + (page%4) * 2 * blk + blk;\n\
    \n\
"
"\
    //decide invA12 location for each page\n\
    C = d_dinvA + page_block*NB*NB + ((page%4)*blk*2 + blk) * NB + (page%4) * 2 * blk;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    //each work iteam loads half a row\n\
    lA[idx][0+idy*12] = Ain[idx + idy*12*lda];\n\
    lA[idx][1+idy*12] = Ain[idx + lda + idy*12*lda];\n\
    lA[idx][2+idy*12] = Ain[idx + lda*2 + idy*12*lda];\n\
    lA[idx][3+idy*12] = Ain[idx + lda*3 + idy*12*lda];\n\
    lA[idx][4+idy*12] = Ain[idx + lda*4 + idy*12*lda];\n\
    lA[idx][5+idy*12] = Ain[idx + lda*5 + idy*12*lda];\n\
    lA[idx][6+idy*12] = Ain[idx + lda*6 + idy*12*lda];\n\
    lA[idx][7+idy*12] = Ain[idx + lda*7 + idy*12*lda];\n\
    lA[idx][8+idy*12] = Ain[idx + lda*8 + idy*12*lda];\n\
    lA[idx][9+idy*12] = Ain[idx + lda*9 + idy*12*lda];\n\
    lA[idx][10+idy*12] = Ain[idx + lda*10 + idy*12*lda];\n\
    lA[idx][11+idy*12] = Ain[idx + lda*11 + idy*12*lda];\n\
    \n\
    lB[idx][0+idy*12] = B[idx + idy*12*NB];\n\
    lB[idx][1+idy*12] = B[idx + NB + idy*12*NB];\n\
    lB[idx][2+idy*12] = B[idx + NB*2 + idy*12*NB];\n\
    lB[idx][3+idy*12] = B[idx + NB*3 + idy*12*NB];\n\
    lB[idx][4+idy*12] = B[idx + NB*4 + idy*12*NB];\n\
    lB[idx][5+idy*12] = B[idx + NB*5 + idy*12*NB];\n\
    lB[idx][6+idy*12] = B[idx + NB*6 + idy*12*NB];\n\
    lB[idx][7+idy*12] = B[idx + NB*7 + idy*12*NB];\n\
    lB[idx][8+idy*12] = B[idx + NB*8 + idy*12*NB];\n\
    lB[idx][9+idy*12] = B[idx + NB*9 + idy*12*NB];\n\
    lB[idx][10+idy*12] = B[idx + NB*10 + idy*12*NB];\n\
    lB[idx][11+idy*12] = B[idx + NB*11 + idy*12*NB];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    //do math\n\
    \n\
    uint i = 0;\n\
    \n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
        i = i + 1;\n\
"
"\
    }while(i < 24);\n\
    \n\
    i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
}\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_24_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 24 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 96 this is 2 for 192 this is 4\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [96*number of blocks, 2]\n\
    //each work item in each work group is responsible for 12 elements (half) in that row\n\
    //each work group is responsible for one gemm;\n\
\n\
    \n\
    ////////////// -invA11*invA12\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
    \n\
    const uint page = gidx % npages;//0-3 for 192; 0-1 for 96\n\
    const uint page_block = page/4;//4 pages per page block\n\
    \n\
    __global double *A, *B, *C;\n\
    __local double lA[24][24];\n\
    __local double lB[24][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide invA11 location for each page\n\
    A = d_dinvA + page_block*NB*NB + (page%4)*blk*2 * NB + (page%4) * 2 * blk;\n\
    //decide invA12 location for each page\n\
    B = d_dinvA + page_block*NB*NB + ((page%4)*blk*2 + blk) * NB + (page%4) * 2 * blk;\n\
    C = B;\n\
    //C = d_dinvA + page_block*NB*NB + ((page%4)*blk*2) * NB + (page%4) * 2 * blk + blk;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    //each work iteam loads half a row\n\
    lA[idx][0+idy*12] = A[idx + idy*12*NB];\n\
    lA[idx][1+idy*12] = A[idx + NB + idy*12*NB];\n\
"
"\
    lA[idx][2+idy*12] = A[idx + NB*2 + idy*12*NB];\n\
    lA[idx][3+idy*12] = A[idx + NB*3 + idy*12*NB];\n\
    lA[idx][4+idy*12] = A[idx + NB*4 + idy*12*NB];\n\
    lA[idx][5+idy*12] = A[idx + NB*5 + idy*12*NB];\n\
    lA[idx][6+idy*12] = A[idx + NB*6 + idy*12*NB];\n\
    lA[idx][7+idy*12] = A[idx + NB*7 + idy*12*NB];\n\
    lA[idx][8+idy*12] = A[idx + NB*8 + idy*12*NB];\n\
    lA[idx][9+idy*12] = A[idx + NB*9 + idy*12*NB];\n\
    lA[idx][10+idy*12] = A[idx + NB*10 + idy*12*NB];\n\
    lA[idx][11+idy*12] = A[idx + NB*11 + idy*12*NB];\n\
    \n\
    lB[idx][0+idy*12] = B[idx + idy*12*NB];\n\
    lB[idx][1+idy*12] = B[idx + NB + idy*12*NB];\n\
    lB[idx][2+idy*12] = B[idx + NB*2 + idy*12*NB];\n\
    lB[idx][3+idy*12] = B[idx + NB*3 + idy*12*NB];\n\
    lB[idx][4+idy*12] = B[idx + NB*4 + idy*12*NB];\n\
    lB[idx][5+idy*12] = B[idx + NB*5 + idy*12*NB];\n\
    lB[idx][6+idy*12] = B[idx + NB*6 + idy*12*NB];\n\
    lB[idx][7+idy*12] = B[idx + NB*7 + idy*12*NB];\n\
    lB[idx][8+idy*12] = B[idx + NB*8 + idy*12*NB];\n\
    lB[idx][9+idy*12] = B[idx + NB*9 + idy*12*NB];\n\
    lB[idx][10+idy*12] = B[idx + NB*10 + idy*12*NB];\n\
    lB[idx][11+idy*12] = B[idx + NB*11 + idy*12*NB];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    //do math\n\
    \n\
    uint i = 0;\n\
    \n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
        i = i + 1;\n\
    }while(i < 24);\n\
    \n\
    i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = -1 * privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);    \n\
\n\
"
"\
}\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_48_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 48 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 96 this is 1 for 192 this is 2\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [96*number of blocks, 4]\n\
    //each work item in each work group is responsible for 12 elements (1/4) in that row\n\
    //each work group is responsible for 24 by 24 macro tile;\n\
    \n\
    ////////////// A12*invA22\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
    \n\
    //uint page = gidx / 2;//0-1 for 192; 0 for 96\n\
    const uint page = (gidx/2)%2;//index of page within a page_block; 2 pages per page_block\n\
    const uint page_block = gidx/4;//#index of page_block; 2 WG per page; 4 WG per page_block\n\
    \n\
    __global double *B, *C;\n\
    __local double lA[24][48];\n\
    __local double lB[48][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide A12 location for each page\n\
    //each workgroup loads half of A (left or right)\n\
    Ain = Ain + offAin;\n\
    Ain += page_block*NB*lda + page_block*NB + page*blk*2*lda + page*blk*2 + blk*lda + gidx%2*(blk/2);\n\
    \n\
    //decide invA22 (B) location for each page\n\
    //each workgroup loads half of B (up or down)\n\
    B = d_dinvA + page_block*NB*NB + page*blk*2*NB + page*blk*2 + blk*NB + blk + gidy*(blk/2)*NB;\n\
    \n\
    //decide invA12 location for each page; \n\
    //Actually this will be stored in invA21 temporarily\n\
    //each workgroup writes 1/4 of C\n\
    C = d_dinvA + page_block*NB*NB + page*blk*2*NB + page*blk*2 + blk*NB + gidx%2*(blk/2) + gidy*(blk/2)*NB;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    //each work item loads a half row of A and half column of B\n\
    //idx 0-23 idy 0-1\n\
    lA[idx][0+idy*24] = Ain[idx + idy*24*lda];\n\
"
"\
    lA[idx][1+idy*24] = Ain[idx + lda + idy*24*lda];\n\
    lA[idx][2+idy*24] = Ain[idx + lda*2 + idy*24*lda];\n\
    lA[idx][3+idy*24] = Ain[idx + lda*3 + idy*24*lda];\n\
    lA[idx][4+idy*24] = Ain[idx + lda*4 + idy*24*lda];\n\
    lA[idx][5+idy*24] = Ain[idx + lda*5 + idy*24*lda];\n\
    lA[idx][6+idy*24] = Ain[idx + lda*6 + idy*24*lda];\n\
    lA[idx][7+idy*24] = Ain[idx + lda*7 + idy*24*lda];\n\
    lA[idx][8+idy*24] = Ain[idx + lda*8 + idy*24*lda];\n\
    lA[idx][9+idy*24] = Ain[idx + lda*9 + idy*24*lda];\n\
    lA[idx][10+idy*24] = Ain[idx + lda*10 + idy*24*lda];\n\
    lA[idx][11+idy*24] = Ain[idx + lda*11 + idy*24*lda];\n\
    lA[idx][12+idy*24] = Ain[idx + lda*12 + idy*24*lda];\n\
    lA[idx][13+idy*24] = Ain[idx + lda*13 + idy*24*lda];\n\
    lA[idx][14+idy*24] = Ain[idx + lda*14 + idy*24*lda];\n\
    lA[idx][15+idy*24] = Ain[idx + lda*15 + idy*24*lda];\n\
    lA[idx][16+idy*24] = Ain[idx + lda*16 + idy*24*lda];\n\
    lA[idx][17+idy*24] = Ain[idx + lda*17 + idy*24*lda];\n\
    lA[idx][18+idy*24] = Ain[idx + lda*18 + idy*24*lda];\n\
    lA[idx][19+idy*24] = Ain[idx + lda*19 + idy*24*lda];\n\
    lA[idx][20+idy*24] = Ain[idx + lda*20 + idy*24*lda];\n\
    lA[idx][21+idy*24] = Ain[idx + lda*21 + idy*24*lda];\n\
    lA[idx][22+idy*24] = Ain[idx + lda*22 + idy*24*lda];\n\
    lA[idx][23+idy*24] = Ain[idx + lda*23 + idy*24*lda];\n\
    \n\
    lB[0+idy*24][idx] = B[idx*NB + idy*24];\n\
    lB[1+idy*24][idx]  = B[idx*NB + idy*24 + 1];\n\
    lB[2+idy*24][idx]  = B[idx*NB + idy*24 + 2];\n\
    lB[3+idy*24][idx]  = B[idx*NB + idy*24 + 3];\n\
    lB[4+idy*24][idx]  = B[idx*NB + idy*24 + 4];\n\
    lB[5+idy*24][idx]  = B[idx*NB + idy*24 + 5];\n\
    lB[6+idy*24][idx]  = B[idx*NB + idy*24 + 6];\n\
    lB[7+idy*24][idx]  = B[idx*NB + idy*24 + 7];\n\
    lB[8+idy*24][idx]  = B[idx*NB + idy*24 + 8];\n\
    lB[9+idy*24][idx]  = B[idx*NB + idy*24 + 9];\n\
    lB[10+idy*24][idx]  = B[idx*NB + idy*24 + 10];\n\
    lB[11+idy*24][idx]  = B[idx*NB + idy*24 + 11];\n\
    lB[12+idy*24][idx]  = B[idx*NB + idy*24 + 12];\n\
    lB[13+idy*24][idx]  = B[idx*NB + idy*24 + 13];\n\
    lB[14+idy*24][idx]  = B[idx*NB + idy*24 + 14];\n\
    lB[15+idy*24][idx]  = B[idx*NB + idy*24 + 15];\n\
    lB[16+idy*24][idx]  = B[idx*NB + idy*24 + 16];\n\
    lB[17+idy*24][idx]  = B[idx*NB + idy*24 + 17];\n\
    lB[18+idy*24][idx]  = B[idx*NB + idy*24 + 18];\n\
    lB[19+idy*24][idx]  = B[idx*NB + idy*24 + 19];\n\
    lB[20+idy*24][idx]  = B[idx*NB + idy*24 + 20];\n\
    lB[21+idy*24][idx]  = B[idx*NB + idy*24 + 21];\n\
    lB[22+idy*24][idx]  = B[idx*NB + idy*24 + 22];\n\
    lB[23+idy*24][idx]  = B[idx*NB + idy*24 + 23];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
"
"\
    //do math\n\
    \n\
    uint i = 0;\n\
    \n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
        i = i + 1;\n\
    }while(i < 48);\n\
    \n\
    i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
    \n\
}\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_48_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 48 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 96 this is 1 for 192 this is 2\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [96*number of blocks, 4]\n\
    //each work item in each work group is responsible for 12 elements (1/4) in that row\n\
    //each work group is responsible for 24 by 24 macro tile;\n\
    \n\
    ////////////// -invA11*invA12\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
    \n\
"
"\
    //uint page = gidx / 2;//0-1 for 192; 0 for 96\n\
    const uint page = (gidx/2)%2;//index of page within a page_block; 2 pages per page_block\n\
    const uint page_block = gidx/4;//#index of page_block; 2 WG per page; 4 WG per page_block\n\
    \n\
    __global double *A, *B, *C;\n\
    __local double lA[24][48];\n\
    __local double lB[48][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide invA11 location for each page\n\
    //each workgroup loads half of A (left or right)\n\
    A = d_dinvA + page_block*NB*NB + page*blk*2*NB + page*blk*2 + gidx%2*(blk/2);\n\
    \n\
    //decide invA12 (B) location for each page\n\
    //actually it was saved in invA21 from last kernel\n\
    //each workgroup loads half of B (up or down)\n\
    B = d_dinvA + page_block*NB*NB + page*blk*2*NB + page*blk*2 + blk*NB + gidy*(blk/2)*NB;\n\
    \n\
    //decide invA12 location for each page\n\
    //each workgroup writes 1/4 of C\n\
    C = d_dinvA + page_block*NB*NB + page*blk*2*NB + page*blk*2 + blk*NB + gidx%2*(blk/2) + gidy*(blk/2)*NB;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    //each work item loads a half row of A and half column of B\n\
    //idx 0-23 idy 0-1\n\
    lA[idx][0+idy*24] = A[idx + idy*24*NB];\n\
    lA[idx][1+idy*24] = A[idx + NB + idy*24*NB];\n\
    lA[idx][2+idy*24] = A[idx + NB*2 + idy*24*NB];\n\
    lA[idx][3+idy*24] = A[idx + NB*3 + idy*24*NB];\n\
    lA[idx][4+idy*24] = A[idx + NB*4 + idy*24*NB];\n\
    lA[idx][5+idy*24] = A[idx + NB*5 + idy*24*NB];\n\
    lA[idx][6+idy*24] = A[idx + NB*6 + idy*24*NB];\n\
    lA[idx][7+idy*24] = A[idx + NB*7 + idy*24*NB];\n\
    lA[idx][8+idy*24] = A[idx + NB*8 + idy*24*NB];\n\
    lA[idx][9+idy*24] = A[idx + NB*9 + idy*24*NB];\n\
    lA[idx][10+idy*24] = A[idx + NB*10 + idy*24*NB];\n\
    lA[idx][11+idy*24] = A[idx + NB*11 + idy*24*NB];\n\
    lA[idx][12+idy*24] = A[idx + NB*12 + idy*24*NB];\n\
    lA[idx][13+idy*24] = A[idx + NB*13 + idy*24*NB];\n\
    lA[idx][14+idy*24] = A[idx + NB*14 + idy*24*NB];\n\
    lA[idx][15+idy*24] = A[idx + NB*15 + idy*24*NB];\n\
    lA[idx][16+idy*24] = A[idx + NB*16 + idy*24*NB];\n\
    lA[idx][17+idy*24] = A[idx + NB*17 + idy*24*NB];\n\
    lA[idx][18+idy*24] = A[idx + NB*18 + idy*24*NB];\n\
    lA[idx][19+idy*24] = A[idx + NB*19 + idy*24*NB];\n\
    lA[idx][20+idy*24] = A[idx + NB*20 + idy*24*NB];\n\
    lA[idx][21+idy*24] = A[idx + NB*21 + idy*24*NB];\n\
    lA[idx][22+idy*24] = A[idx + NB*22 + idy*24*NB];\n\
    lA[idx][23+idy*24] = A[idx + NB*23 + idy*24*NB];\n\
    \n\
"
"\
    lB[0+idy*24][idx] = B[idx*NB + idy*24];\n\
    lB[1+idy*24][idx]  = B[idx*NB + idy*24 + 1];\n\
    lB[2+idy*24][idx]  = B[idx*NB + idy*24 + 2];\n\
    lB[3+idy*24][idx]  = B[idx*NB + idy*24 + 3];\n\
    lB[4+idy*24][idx]  = B[idx*NB + idy*24 + 4];\n\
    lB[5+idy*24][idx]  = B[idx*NB + idy*24 + 5];\n\
    lB[6+idy*24][idx]  = B[idx*NB + idy*24 + 6];\n\
    lB[7+idy*24][idx]  = B[idx*NB + idy*24 + 7];\n\
    lB[8+idy*24][idx]  = B[idx*NB + idy*24 + 8];\n\
    lB[9+idy*24][idx]  = B[idx*NB + idy*24 + 9];\n\
    lB[10+idy*24][idx]  = B[idx*NB + idy*24 + 10];\n\
    lB[11+idy*24][idx]  = B[idx*NB + idy*24 + 11];\n\
    lB[12+idy*24][idx]  = B[idx*NB + idy*24 + 12];\n\
    lB[13+idy*24][idx]  = B[idx*NB + idy*24 + 13];\n\
    lB[14+idy*24][idx]  = B[idx*NB + idy*24 + 14];\n\
    lB[15+idy*24][idx]  = B[idx*NB + idy*24 + 15];\n\
    lB[16+idy*24][idx]  = B[idx*NB + idy*24 + 16];\n\
    lB[17+idy*24][idx]  = B[idx*NB + idy*24 + 17];\n\
    lB[18+idy*24][idx]  = B[idx*NB + idy*24 + 18];\n\
    lB[19+idy*24][idx]  = B[idx*NB + idy*24 + 19];\n\
    lB[20+idy*24][idx]  = B[idx*NB + idy*24 + 20];\n\
    lB[21+idy*24][idx]  = B[idx*NB + idy*24 + 21];\n\
    lB[22+idy*24][idx]  = B[idx*NB + idy*24 + 22];\n\
    lB[23+idy*24][idx]  = B[idx*NB + idy*24 + 23];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    //do math\n\
    \n\
    uint i = 0;\n\
    \n\
    do{\n\
        privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
        privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
        privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
        privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
        privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
        privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
        privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
        privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
        privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
        privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
        privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
        privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
        i = i + 1;\n\
    }while(i < 48);\n\
    \n\
    i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = -1 * privateC[i];\n\
        i = i + 1;\n\
"
"\
    }while(i < 12);\n\
    \n\
    \n\
}\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_96_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 96 here.\n\
    // lda in leading dimension. Column major here\n\
    // npages = (na-1)/12*2 + 1; for 192 this is 1 for 384 this is 2\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [96*number of blocks, 8]\n\
    //each work item in each work group is responsible for 12 elements (1/8) in that row\n\
    //each work group is responsible for 24 by 24 macro tile;\n\
    \n\
    ////////////// A12*invA22\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
    \n\
    //uint page = gidx / 2;//0-1 for 192; 0 for 96\n\
    //const uint page = (gidx/4)%1;//index of page within a page_block; 1 pages per page_block\n\
    const uint page_block = gidx/4;//#index of page_block; 4 WG per page; 4 WG per page_block\n\
    \n\
    \n\
    __global double *B, *C;\n\
    __local double lA[24][48];\n\
    __local double lB[48][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide A12 location for each page\n\
    //each workgroup loads 1/4 of A (left or right)\n\
    Ain = Ain + offAin;\n\
    Ain += page_block*NB*lda + page_block*NB + blk*lda + gidx%4*(blk/4);\n\
    \n\
    //decide invA22 (B) location for each page\n\
    //each workgroup loads 1/4 of B (up or down)\n\
    B = d_dinvA + page_block*NB*NB + blk*NB + blk + gidy*(blk/4)*NB;\n\
    \n\
    //decide invA12 location for each page; \n\
    //Actually this will be stored in invA21 temporarily\n\
    //each workgroup writes 1/4*1/4 of C\n\
    C = d_dinvA + page_block*NB*NB + blk*NB + gidx%4*(blk/4) + gidy*(blk/4)*NB;\n\
    \n\
"
"\
    //read A and B into LDS no transpose operated here\n\
    //each work item loads a half row of A and half column of B\n\
    //each loop loads 1/4 row of A and 1/4 column of B\n\
    //idx 0-23 idy 0-1\n\
    \n\
    uint block_k = blk / 48; //thus we need 2 iterations here\n\
    do{\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        lA[idx][0+idy*24] = Ain[idx + idy*24*lda];\n\
        lA[idx][1+idy*24] = Ain[idx + lda + idy*24*lda];\n\
        lA[idx][2+idy*24] = Ain[idx + lda*2 + idy*24*lda];\n\
        lA[idx][3+idy*24] = Ain[idx + lda*3 + idy*24*lda];\n\
        lA[idx][4+idy*24] = Ain[idx + lda*4 + idy*24*lda];\n\
        lA[idx][5+idy*24] = Ain[idx + lda*5 + idy*24*lda];\n\
        lA[idx][6+idy*24] = Ain[idx + lda*6 + idy*24*lda];\n\
        lA[idx][7+idy*24] = Ain[idx + lda*7 + idy*24*lda];\n\
        lA[idx][8+idy*24] = Ain[idx + lda*8 + idy*24*lda];\n\
        lA[idx][9+idy*24] = Ain[idx + lda*9 + idy*24*lda];\n\
        lA[idx][10+idy*24] = Ain[idx + lda*10 + idy*24*lda];\n\
        lA[idx][11+idy*24] = Ain[idx + lda*11 + idy*24*lda];\n\
        lA[idx][12+idy*24] = Ain[idx + lda*12 + idy*24*lda];\n\
        lA[idx][13+idy*24] = Ain[idx + lda*13 + idy*24*lda];\n\
        lA[idx][14+idy*24] = Ain[idx + lda*14 + idy*24*lda];\n\
        lA[idx][15+idy*24] = Ain[idx + lda*15 + idy*24*lda];\n\
        lA[idx][16+idy*24] = Ain[idx + lda*16 + idy*24*lda];\n\
        lA[idx][17+idy*24] = Ain[idx + lda*17 + idy*24*lda];\n\
        lA[idx][18+idy*24] = Ain[idx + lda*18 + idy*24*lda];\n\
        lA[idx][19+idy*24] = Ain[idx + lda*19 + idy*24*lda];\n\
        lA[idx][20+idy*24] = Ain[idx + lda*20 + idy*24*lda];\n\
        lA[idx][21+idy*24] = Ain[idx + lda*21 + idy*24*lda];\n\
        lA[idx][22+idy*24] = Ain[idx + lda*22 + idy*24*lda];\n\
        lA[idx][23+idy*24] = Ain[idx + lda*23 + idy*24*lda];\n\
        \n\
        lB[0+idy*24][idx] = B[idx*NB + idy*24];\n\
        lB[1+idy*24][idx]  = B[idx*NB + idy*24 + 1];\n\
        lB[2+idy*24][idx]  = B[idx*NB + idy*24 + 2];\n\
        lB[3+idy*24][idx]  = B[idx*NB + idy*24 + 3];\n\
        lB[4+idy*24][idx]  = B[idx*NB + idy*24 + 4];\n\
        lB[5+idy*24][idx]  = B[idx*NB + idy*24 + 5];\n\
        lB[6+idy*24][idx]  = B[idx*NB + idy*24 + 6];\n\
        lB[7+idy*24][idx]  = B[idx*NB + idy*24 + 7];\n\
        lB[8+idy*24][idx]  = B[idx*NB + idy*24 + 8];\n\
        lB[9+idy*24][idx]  = B[idx*NB + idy*24 + 9];\n\
        lB[10+idy*24][idx]  = B[idx*NB + idy*24 + 10];\n\
        lB[11+idy*24][idx]  = B[idx*NB + idy*24 + 11];\n\
        lB[12+idy*24][idx]  = B[idx*NB + idy*24 + 12];\n\
        lB[13+idy*24][idx]  = B[idx*NB + idy*24 + 13];\n\
        lB[14+idy*24][idx]  = B[idx*NB + idy*24 + 14];\n\
        lB[15+idy*24][idx]  = B[idx*NB + idy*24 + 15];\n\
        lB[16+idy*24][idx]  = B[idx*NB + idy*24 + 16];\n\
"
"\
        lB[17+idy*24][idx]  = B[idx*NB + idy*24 + 17];\n\
        lB[18+idy*24][idx]  = B[idx*NB + idy*24 + 18];\n\
        lB[19+idy*24][idx]  = B[idx*NB + idy*24 + 19];\n\
        lB[20+idy*24][idx]  = B[idx*NB + idy*24 + 20];\n\
        lB[21+idy*24][idx]  = B[idx*NB + idy*24 + 21];\n\
        lB[22+idy*24][idx]  = B[idx*NB + idy*24 + 22];\n\
        lB[23+idy*24][idx]  = B[idx*NB + idy*24 + 23];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        //do math\n\
        \n\
        uint i = 0;\n\
        \n\
        do{\n\
            privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
            privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
            privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
            privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
            privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
            privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
            privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
            privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
            privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
            privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
            privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
            privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
            i = i + 1;\n\
        }while(i < 48);\n\
        \n\
        Ain += 48*lda;\n\
        B += 48;\n\
    }while(--block_k>0);\n\
    \n\
    uint i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
    \n\
}\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_96_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    // Ain is the non inverse matrix; the size of Ain is lda * na\n\
    // offAin is the offset of Ain\n\
    // d_dinvA is the inversed matrix. the size of d_invA is NB * (na-1)/NB + 1\n\
    // blk is subblock size, which is 48 here.\n\
    // lda in leading dimension. Column major here\n\
"
"\
    // npages = (na-1)/12*2 + 1; for 96 this is 1 for 192 this is 2\n\
\n\
    //Work group size is [24, 2]\n\
    //global work size is [48*number of blocks, 4]\n\
    //each work item in each work group is responsible for 12 elements (1/4) in that row\n\
    //each work group is responsible for 24 by 24 macro tile;\n\
    \n\
    ////////////// -invA11*invA12\n\
    const uint gidx = get_group_id(0);\n\
    const uint gidy = get_group_id(1);\n\
    const uint idx = get_local_id(0);\n\
    const uint idy = get_local_id(1);\n\
    \n\
    //uint page = gidx / 2;//0-1 for 192; 0 for 96\n\
    //const uint page = (gidx/2)%2;//index of page within a page_block; 1 pages per page_block\n\
    const uint page_block = gidx/4;//#index of page_block; 4 WG per page; 4 WG per page_block\n\
    \n\
    __global double *A, *B, *C;\n\
    __local double lA[24][48];\n\
    __local double lB[48][24];\n\
    double privateC[12] = {(double)0};\n\
    \n\
    //decide invA11 location for each page\n\
    //each workgroup loads half of A (left or right)\n\
    //A = d_dinvA + page*NB*NB + gidx%2*(blk/2);\n\
    A = d_dinvA + page_block*NB*NB + gidx%4*(blk/4);\n\
    \n\
    //decide invA12 (B) location for each page\n\
    //actually it was saved in invA21 from last kernel\n\
    //each workgroup loads half of B (up or down)\n\
    //B = d_dinvA + page*NB*NB + blk*NB + gidy*(blk/2)*NB;\n\
    B = d_dinvA + page_block*NB*NB + blk*NB + gidy*(blk/4)*NB;\n\
    \n\
    //decide invA12 location for each page\n\
    //each workgroup writes 1/4 of C\n\
    //C = d_dinvA + page*NB*NB + blk * NB + gidx%2*(blk/2) + gidy*(blk/2)*NB;\n\
    C = d_dinvA + page_block*NB*NB + blk*NB + gidx%4*(blk/4) + gidy*(blk/4)*NB;\n\
    \n\
    //read A and B into LDS no transpose operated here\n\
    //each work item loads a half row of A and half column of B\n\
    //idx 0-23 idy 0-1\n\
    \n\
    uint block_k = blk / 48; //thus we need 2 iterations here\n\
    do{\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        lA[idx][0+idy*24] = A[idx + idy*24*NB];\n\
        lA[idx][1+idy*24] = A[idx + NB + idy*24*NB];\n\
        lA[idx][2+idy*24] = A[idx + NB*2 + idy*24*NB];\n\
        lA[idx][3+idy*24] = A[idx + NB*3 + idy*24*NB];\n\
        lA[idx][4+idy*24] = A[idx + NB*4 + idy*24*NB];\n\
"
"\
        lA[idx][5+idy*24] = A[idx + NB*5 + idy*24*NB];\n\
        lA[idx][6+idy*24] = A[idx + NB*6 + idy*24*NB];\n\
        lA[idx][7+idy*24] = A[idx + NB*7 + idy*24*NB];\n\
        lA[idx][8+idy*24] = A[idx + NB*8 + idy*24*NB];\n\
        lA[idx][9+idy*24] = A[idx + NB*9 + idy*24*NB];\n\
        lA[idx][10+idy*24] = A[idx + NB*10 + idy*24*NB];\n\
        lA[idx][11+idy*24] = A[idx + NB*11 + idy*24*NB];\n\
        lA[idx][12+idy*24] = A[idx + NB*12 + idy*24*NB];\n\
        lA[idx][13+idy*24] = A[idx + NB*13 + idy*24*NB];\n\
        lA[idx][14+idy*24] = A[idx + NB*14 + idy*24*NB];\n\
        lA[idx][15+idy*24] = A[idx + NB*15 + idy*24*NB];\n\
        lA[idx][16+idy*24] = A[idx + NB*16 + idy*24*NB];\n\
        lA[idx][17+idy*24] = A[idx + NB*17 + idy*24*NB];\n\
        lA[idx][18+idy*24] = A[idx + NB*18 + idy*24*NB];\n\
        lA[idx][19+idy*24] = A[idx + NB*19 + idy*24*NB];\n\
        lA[idx][20+idy*24] = A[idx + NB*20 + idy*24*NB];\n\
        lA[idx][21+idy*24] = A[idx + NB*21 + idy*24*NB];\n\
        lA[idx][22+idy*24] = A[idx + NB*22 + idy*24*NB];\n\
        lA[idx][23+idy*24] = A[idx + NB*23 + idy*24*NB];\n\
        \n\
        lB[0+idy*24][idx] = B[idx*NB + idy*24];\n\
        lB[1+idy*24][idx]  = B[idx*NB + idy*24 + 1];\n\
        lB[2+idy*24][idx]  = B[idx*NB + idy*24 + 2];\n\
        lB[3+idy*24][idx]  = B[idx*NB + idy*24 + 3];\n\
        lB[4+idy*24][idx]  = B[idx*NB + idy*24 + 4];\n\
        lB[5+idy*24][idx]  = B[idx*NB + idy*24 + 5];\n\
        lB[6+idy*24][idx]  = B[idx*NB + idy*24 + 6];\n\
        lB[7+idy*24][idx]  = B[idx*NB + idy*24 + 7];\n\
        lB[8+idy*24][idx]  = B[idx*NB + idy*24 + 8];\n\
        lB[9+idy*24][idx]  = B[idx*NB + idy*24 + 9];\n\
        lB[10+idy*24][idx]  = B[idx*NB + idy*24 + 10];\n\
        lB[11+idy*24][idx]  = B[idx*NB + idy*24 + 11];\n\
        lB[12+idy*24][idx]  = B[idx*NB + idy*24 + 12];\n\
        lB[13+idy*24][idx]  = B[idx*NB + idy*24 + 13];\n\
        lB[14+idy*24][idx]  = B[idx*NB + idy*24 + 14];\n\
        lB[15+idy*24][idx]  = B[idx*NB + idy*24 + 15];\n\
        lB[16+idy*24][idx]  = B[idx*NB + idy*24 + 16];\n\
        lB[17+idy*24][idx]  = B[idx*NB + idy*24 + 17];\n\
        lB[18+idy*24][idx]  = B[idx*NB + idy*24 + 18];\n\
        lB[19+idy*24][idx]  = B[idx*NB + idy*24 + 19];\n\
        lB[20+idy*24][idx]  = B[idx*NB + idy*24 + 20];\n\
        lB[21+idy*24][idx]  = B[idx*NB + idy*24 + 21];\n\
        lB[22+idy*24][idx]  = B[idx*NB + idy*24 + 22];\n\
        lB[23+idy*24][idx]  = B[idx*NB + idy*24 + 23];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        //do math\n\
        \n\
        uint i = 0;\n\
        \n\
"
"\
        do{\n\
            privateC[0]=mad(lA[idx][i],lB[i][0+idy*12],privateC[0]); \n\
            privateC[1]=mad(lA[idx][i],lB[i][1+idy*12],privateC[1]); \n\
            privateC[2]=mad(lA[idx][i],lB[i][2+idy*12],privateC[2]); \n\
            privateC[3]=mad(lA[idx][i],lB[i][3+idy*12],privateC[3]); \n\
            privateC[4]=mad(lA[idx][i],lB[i][4+idy*12],privateC[4]); \n\
            privateC[5]=mad(lA[idx][i],lB[i][5+idy*12],privateC[5]); \n\
            privateC[6]=mad(lA[idx][i],lB[i][6+idy*12],privateC[6]); \n\
            privateC[7]=mad(lA[idx][i],lB[i][7+idy*12],privateC[7]); \n\
            privateC[8]=mad(lA[idx][i],lB[i][8+idy*12],privateC[8]); \n\
            privateC[9]=mad(lA[idx][i],lB[i][9+idy*12],privateC[9]); \n\
            privateC[10]=mad(lA[idx][i],lB[i][10+idy*12],privateC[10]); \n\
            privateC[11]=mad(lA[idx][i],lB[i][11+idy*12],privateC[11]); \n\
            i = i + 1;\n\
        }while(i < 48);\n\
        \n\
        A += 48*NB;\n\
        B += 48;\n\
    \n\
    }while(--block_k>0);\n\
    \n\
    uint i = 0;\n\
    do{\n\
        C[NB*idy*12+NB*i+idx] = -1 * privateC[i];\n\
        i = i + 1;\n\
    }while(i < 12);\n\
    \n\
    \n\
}\n\
\n\
";


