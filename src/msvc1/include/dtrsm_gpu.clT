
static const char * dtrsm_gpu_kernels = "\
\n\
//#define __mul(i,j) ((i)*(j))\n\
//#define qmod(a, b) ((a)-(__mul((b), (a)/(b))))\n\
\n\
#define __mul(i,j) ((i)*(j))\n\
#define qmod(a, b) ((a)%(b))\n\
\n\
\n\
#define BLOCK_SIZE 16 // inner blocking size, <=32\n\
#define NB 128        // outer blocking size, >BLOCK_SIZE\n\
\n\
#define ZERO              ( 0.0)\n\
#define ONE               ( 1.0)\n\
\n\
#ifdef DOUBLE_PRECISION\n\
#ifdef cl_khr_fp64\n\
#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n\
#else\n\
#pragma OPENCL EXTENSION cl_amd_fp64 : enable\n\
#endif\n\
#endif\n\
\n\
__kernel void DIAG_DTRTRI_KERNEL_UPPER(int  isDiagUnit, \n\
                       __global double const * restrict A,\n\
                                       uint offA,\n\
                       __global double *d_dinvA,\n\
                       uint lda,\n\
                                       uint na)\n\
{\n\
\n\
  int i, j;\n\
  double Ystx = 0;\n\
  __local double *y = 0;\n\
  double switcher;\n\
  double neg_switcher;\n\
\n\
  // Thread index\n\
  int tx = get_local_id(0);\n\
\n\
  // Thread index\n\
  int gx = get_global_id(0);\n\
\n\
  // Block index\n\
  int bx = get_group_id(0);\n\
\n\
  A = A + offA;\n\
\n\
  __global const double *Aoff = A + bx*lda*BLOCK_SIZE + bx*BLOCK_SIZE;\n\
  int NumBLperNB = NB/BLOCK_SIZE;\n\
"
"\
  d_dinvA += bx/NumBLperNB*NB*NB + (bx % NumBLperNB)*(NB*BLOCK_SIZE + BLOCK_SIZE);\n\
\n\
  __local double Bs[BLOCK_SIZE*BLOCK_SIZE];\n\
  __local double workspace[BLOCK_SIZE];    // workspace used to store the current working column\n\
\n\
  // load A\n\
  #pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    {\n\
      if(tx <= i && i+bx*BLOCK_SIZE < na )\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = *(Aoff+i*lda+tx);    \n\
        }\n\
      else\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = ZERO; \n\
        }\n\
    } \n\
  // read in the whole square block of my A and zero out the non data triangular\n\
 \n\
  // Synchronize to make sure the matrices are loaded\n\
  //__syncthreads(); \n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  // solve the diagonals\n\
\n\
  if(isDiagUnit == 1)\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;\n\
    }\n\
  else\n\
    {\n\
      if( Bs[tx*BLOCK_SIZE+tx] == ZERO )\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;  \n\
    }\n\
      else\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE / ( Bs[tx*BLOCK_SIZE+tx]) ;\n\
    }      \n\
    }\n\
\n\
\n\
  /* the upper case */\n\
  for( i=0; i < BLOCK_SIZE; i++ ) {\n\
    Ystx =  ZERO;\n\
    if( tx < i)\n\
      {\n\
    switcher = ONE;\n\
      }\n\
"
"\
    else\n\
      {\n\
    switcher = ZERO;\n\
      }\n\
\n\
    //dtrmv\n\
    workspace[tx] = *(Bs+i*BLOCK_SIZE+tx);\n\
    y = Bs+i*BLOCK_SIZE;\n\
\n\
    #pragma unroll\n\
    //for( j=tx; j < i; j++ )\n\
    for( j=0; j < i; j++ )\n\
      Ystx += switcher * (*(Bs+j*BLOCK_SIZE+tx)*workspace[j]);\n\
\n\
    //sscal\n\
    // if (tx != i) y[tx]=switcher*Ystx*(-Bs[i*BLOCK_SIZE+i]);\n\
\n\
    if( tx != i)\n\
      {\n\
    switcher = ONE;\n\
    neg_switcher =  ZERO;\n\
      }\n\
    else\n\
      {\n\
    switcher = ZERO;\n\
    neg_switcher =  ONE;\n\
      }\n\
\n\
    y[tx] = switcher *Ystx*(-Bs[i*BLOCK_SIZE+i])+neg_switcher*y[tx];\n\
\n\
    // __syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
  }\n\
\n\
  // write back A\n\
#pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    *(d_dinvA+i*NB+tx) = Bs[i*BLOCK_SIZE+tx];\n\
\n\
}\n\
\n\
\n\
//--------------------------------------------------------------------------//\n\
//--------------------------------------------------------------------------//\n\
//--------------------------------------------------------------------------//\n\
//--------------------------------------------------------------------------//\n\
\n\
\n\
__kernel void DIAG_DTRTRI_KERNEL_LOWER(int isDiagUnit, \n\
                       __global double const * restrict A,\n\
"
"\
                                       uint offA,\n\
                       __global double *d_dinvA,\n\
                       uint lda,\n\
                                       uint na)\n\
{\n\
  \n\
  int i, j;\n\
  double Ystx=  0;\n\
  __local double *Bw=0, *x=0, *y=0;\n\
  double switcher;\n\
  double neg_switcher;\n\
\n\
\n\
 // Thread index\n\
  int tx = get_local_id(0);\n\
  int txw;\n\
\n\
  int gx = get_global_id(0);\n\
\n\
  // Block index\n\
  int bx = get_group_id(0);\n\
\n\
  A = A + offA;\n\
\n\
  __global const double *Aoff = A+bx*lda*BLOCK_SIZE+bx*BLOCK_SIZE;\n\
  int NumBLperNB = NB/BLOCK_SIZE;\n\
  d_dinvA += bx/NumBLperNB*NB*NB + (bx % NumBLperNB)*(NB*BLOCK_SIZE + BLOCK_SIZE);\n\
\n\
  __local double Bs[BLOCK_SIZE*BLOCK_SIZE];\n\
  __local double workspace[BLOCK_SIZE];    // workspace used to store the current working column\n\
\n\
  // load A\n\
#pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    {\n\
      if(tx >= i && gx < na )\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = *(Aoff+i*lda+tx);\n\
        }\n\
      else\n\
        {\n\
      Bs[i*BLOCK_SIZE+tx] = ZERO;\n\
        }\n\
    }\n\
\n\
  // read in the whole square block of my A and zero out the non data triangular\n\
  // not the upper or lower diagonal\n\
\n\
  // Synchronize to make sure the matrices are loaded\n\
  //__syncthreads();\n\
"
"\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
  // solve the diagonals\n\
\n\
  if(isDiagUnit == 1)\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;\n\
    }\n\
  else\n\
    {\n\
      if( Bs[tx*BLOCK_SIZE+tx] == ZERO )\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE;  \n\
    }\n\
      else\n\
    {\n\
      Bs[tx*BLOCK_SIZE+tx] = ONE / ( Bs[tx*BLOCK_SIZE+tx]) ;\n\
    }      \n\
    }\n\
\n\
  /*\n\
   * the lower case\n\
   */\n\
\n\
\n\
  if( !(tx < BLOCK_SIZE-1) )\n\
    {\n\
      switcher = ONE;\n\
    }\n\
  else\n\
    {\n\
      switcher = ZERO;\n\
    }\n\
\n\
  Bs[(BLOCK_SIZE-1)*BLOCK_SIZE+tx] = switcher * Bs[(BLOCK_SIZE-1)*BLOCK_SIZE+tx];    \n\
  // zero out the last column, except the diagonal element\n\
\n\
  for( i=BLOCK_SIZE-2; i >= 0; i-- ) {\n\
    Ystx =  ZERO;\n\
       \n\
    if( tx > i)\n\
      {\n\
    switcher = ONE;\n\
      }\n\
    else\n\
      {\n\
    switcher = ZERO;\n\
      }\n\
\n\
"
"\
    //dtrmv\n\
    Bw = Bs+(i+1)*BLOCK_SIZE+i+1;\n\
    workspace[tx] = *(Bs+i*BLOCK_SIZE+tx);\n\
    x = workspace+i+1;\n\
    y = Bs+i*BLOCK_SIZE;\n\
\n\
    txw = (tx-i-1);\n\
\n\
#pragma unroll\n\
    for( j=0; j < BLOCK_SIZE-i-1; j++ )\n\
      Ystx += switcher*(*(Bw+j*BLOCK_SIZE+txw)*x[j]);\n\
\n\
    //sscal\n\
\n\
    if( tx != i)\n\
      {\n\
    switcher = ONE;\n\
    neg_switcher =  ZERO;\n\
      }\n\
    else\n\
      {\n\
    switcher = ZERO;\n\
    neg_switcher =  ONE;\n\
      }\n\
\n\
    y[tx] = switcher * Ystx*(-Bs[i*BLOCK_SIZE+i])+ neg_switcher *y[tx];\n\
\n\
    //__syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  }\n\
\n\
  // write back A\n\
#pragma unroll\n\
  for( i=0; i < BLOCK_SIZE; i++ )\n\
    *(d_dinvA+i*NB+tx) = Bs[i*BLOCK_SIZE+tx];\n\
}\n\
\n\
\n\
/*\n\
 * daxpy computes c += alpha*b, where b and c are 16-element vectors.\n\
 */\n\
static void daxpy(\n\
    double alpha,\n\
    __local const double * __restrict__ b,\n\
    double * __restrict__ c )\n\
{\n\
    c[0]  += alpha * b[0];\n\
    c[1]  += alpha * b[1];\n\
    c[2]  += alpha * b[2];\n\
"
"\
    c[3]  += alpha * b[3];\n\
    c[4]  += alpha * b[4];\n\
    c[5]  += alpha * b[5];\n\
    c[6]  += alpha * b[6];\n\
    c[7]  += alpha * b[7];\n\
    c[8]  += alpha * b[8];\n\
    c[9]  += alpha * b[9];\n\
    c[10] += alpha * b[10];\n\
    c[11] += alpha * b[11];\n\
    c[12] += alpha * b[12];\n\
    c[13] += alpha * b[13];\n\
    c[14] += alpha * b[14];\n\
    c[15] += alpha * b[15];\n\
}\n\
\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void \n\
TRIPLE_DGEMM_UPDATE_16_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, uint lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    //const int page = (blockIdx.y)%(npages);\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A12*inv(A22) -> A12\n\
        // A=A12, B=inv(A22), C=A12(d_dinvA)\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + ibx + id ; \n\
        int ya = page*blk*2 + blk ; \n\
"
"\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;  // macro READA will detect overflow on y dimension \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
              \n\
        B = d_dinvA + blk*NB + blk;\n\
        C = d_dinvA + blk*NB;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx   ][iny   ] = B[    0*ldb];\n\
            bs[inx   ][iny+ 4] = B[    4*ldb];\n\
            bs[inx   ][iny+ 8] = B[    8*ldb];\n\
            bs[inx   ][iny+12] = B[   12*ldb];\n\
            bs[inx+ 4][iny   ] = B[ 4+ 0*ldb];\n\
            bs[inx+ 4][iny+ 4] = B[ 4+ 4*ldb];\n\
            bs[inx+ 4][iny+ 8] = B[ 4+ 8*ldb];\n\
            bs[inx+ 4][iny+12] = B[ 4+12*ldb];\n\
            bs[inx+ 8][iny   ] = B[ 8+ 0*ldb];\n\
            bs[inx+ 8][iny+ 4] = B[ 8+ 4*ldb];\n\
            bs[inx+ 8][iny+ 8] = B[ 8+ 8*ldb];\n\
            bs[inx+ 8][iny+12] = B[ 8+12*ldb];\n\
            bs[inx+12][iny   ] = B[12+ 0*ldb];\n\
            bs[inx+12][iny+ 4] = B[12+ 4*ldb];\n\
            bs[inx+12][iny+ 8] = B[12+ 8*ldb];\n\
            bs[inx+12][iny+12] = B[12+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ;\n\
"
"\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
    //__syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
#undef READA\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A11)*A12 -> A12\n\
        // A=inv(A11), B=A12, C=A12\n\
        __global double *A, *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        A = d_dinvA;\n\
        B = C = d_dinvA + blk*NB;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
"
"\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx   ][iny   ] = B[    0*ldb];\n\
            bs[inx   ][iny+ 4] = B[    4*ldb];\n\
            bs[inx   ][iny+ 8] = B[    8*ldb];\n\
            bs[inx   ][iny+12] = B[   12*ldb];\n\
            bs[inx+ 4][iny   ] = B[ 4+ 0*ldb];\n\
            bs[inx+ 4][iny+ 4] = B[ 4+ 4*ldb];\n\
            bs[inx+ 4][iny+ 8] = B[ 4+ 8*ldb];\n\
            bs[inx+ 4][iny+12] = B[ 4+12*ldb];\n\
            bs[inx+ 8][iny   ] = B[ 8+ 0*ldb];\n\
            bs[inx+ 8][iny+ 4] = B[ 8+ 4*ldb];\n\
            bs[inx+ 8][iny+ 8] = B[ 8+ 8*ldb];\n\
            bs[inx+ 8][iny+12] = B[ 8+12*ldb];\n\
            bs[inx+12][iny   ] = B[12+ 0*ldb];\n\
            bs[inx+12][iny+ 4] = B[12+ 4*ldb];\n\
            bs[inx+12][iny+ 8] = B[12+ 8*ldb];\n\
            bs[inx+12][iny+12] = B[12+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
"
"\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
\n\
\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_16_PART1_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    //const int page = (get_group_id(1))%(npages);\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A21*inv(A11) -> A21\n\
        // A=A21, B=inv(A11), C=A21\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        int PagesPerNB = NB/(blk*2);\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + blk + ibx + id ; \n\
        int ya = page*blk*2  ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
"
"\
        if ( xa < na ) \n\
          maxA = lda*na ;  // macro READA will detect overflow on y dimension \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
              \n\
        B = d_dinvA;\n\
        C = d_dinvA + blk;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx   ][iny   ] = B[    0*ldb];\n\
            bs[inx   ][iny+ 4] = B[    4*ldb];\n\
            bs[inx   ][iny+ 8] = B[    8*ldb];\n\
            bs[inx   ][iny+12] = B[   12*ldb];\n\
            bs[inx+ 4][iny   ] = B[ 4+ 0*ldb];\n\
            bs[inx+ 4][iny+ 4] = B[ 4+ 4*ldb];\n\
            bs[inx+ 4][iny+ 8] = B[ 4+ 8*ldb];\n\
            bs[inx+ 4][iny+12] = B[ 4+12*ldb];\n\
            bs[inx+ 8][iny   ] = B[ 8+ 0*ldb];\n\
            bs[inx+ 8][iny+ 4] = B[ 8+ 4*ldb];\n\
            bs[inx+ 8][iny+ 8] = B[ 8+ 8*ldb];\n\
            bs[inx+ 8][iny+12] = B[ 8+12*ldb];\n\
            bs[inx+12][iny   ] = B[12+ 0*ldb];\n\
            bs[inx+12][iny+ 4] = B[12+ 4*ldb];\n\
            bs[inx+12][iny+ 8] = B[12+ 8*ldb];\n\
            bs[inx+12][iny+12] = B[12+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ; \n\
"
"\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
\n\
#undef READA\n\
\n\
    //__syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
}\n\
\n\
\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_16_PART2_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    //--------------------------part two---------------------------//\n\
"
"\
    {\n\
        // -inv(A22)*A21 -> A21\n\
        // A=inv(A22), B=A21, C=A21\n\
        __global double *A, *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        int PagesPerNB = NB/(blk*2);\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA + blk*NB + blk;\n\
        B = C = d_dinvA + blk;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx   ][iny   ] = B[    0*ldb];\n\
            bs[inx   ][iny+ 4] = B[    4*ldb];\n\
            bs[inx   ][iny+ 8] = B[    8*ldb];\n\
            bs[inx   ][iny+12] = B[   12*ldb];\n\
            bs[inx+ 4][iny   ] = B[ 4+ 0*ldb];\n\
            bs[inx+ 4][iny+ 4] = B[ 4+ 4*ldb];\n\
            bs[inx+ 4][iny+ 8] = B[ 4+ 8*ldb];\n\
            bs[inx+ 4][iny+12] = B[ 4+12*ldb];\n\
            bs[inx+ 8][iny   ] = B[ 8+ 0*ldb];\n\
            bs[inx+ 8][iny+ 4] = B[ 8+ 4*ldb];\n\
            bs[inx+ 8][iny+ 8] = B[ 8+ 8*ldb];\n\
            bs[inx+ 8][iny+12] = B[ 8+12*ldb];\n\
            bs[inx+12][iny   ] = B[12+ 0*ldb];\n\
            bs[inx+12][iny+ 4] = B[12+ 4*ldb];\n\
            bs[inx+12][iny+ 8] = B[12+ 8*ldb];\n\
            bs[inx+12][iny+12] = B[12+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
"
"\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
    //__syncthreads();\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_32_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
"
"\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A12*inv(A22) -> A21\n\
        // A=A12, B=inv(A22), C=A12(d_dinvA)\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + ibx + id ; \n\
        int ya = page*blk*2 + blk ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;   // macro READA will detect overflow on y dimension  \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
\n\
        B = d_dinvA + blk*NB + blk;\n\
        C = d_dinvA + blk*NB;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx  ][iny   ] = B[   0*ldb];\n\
            bs[inx  ][iny+ 4] = B[   4*ldb];\n\
            bs[inx  ][iny+ 8] = B[   8*ldb];\n\
            bs[inx  ][iny+12] = B[  12*ldb];\n\
"
"\
            bs[inx+8][iny   ] = B[8+ 0*ldb];\n\
            bs[inx+8][iny+ 4] = B[8+ 4*ldb];\n\
            bs[inx+8][iny+ 8] = B[8+ 8*ldb];\n\
            bs[inx+8][iny+12] = B[8+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
\n\
    //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_32_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
"
"\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A11)*A12 -> A12\n\
        // A=inv(A11), B=A12, C=A12\n\
        __global double *A, *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA;\n\
        B = C = d_dinvA + blk*NB;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx  ][iny   ] = B[   0*ldb];\n\
            bs[inx  ][iny+ 4] = B[   4*ldb];\n\
            bs[inx  ][iny+ 8] = B[   8*ldb];\n\
            bs[inx  ][iny+12] = B[  12*ldb];\n\
            bs[inx+8][iny   ] = B[8+ 0*ldb];\n\
            bs[inx+8][iny+ 4] = B[8+ 4*ldb];\n\
            bs[inx+8][iny+ 8] = B[8+ 8*ldb];\n\
            bs[inx+8][iny+12] = B[8+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
"
"\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_32_PART1_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
"
"\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A21*inv(A11) -> A21\n\
        // A=A21, B=inv(A11), C=A21\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + blk +  ibx + id ; \n\
        int ya = page*blk*2 ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;  // macro READA will detect overflow on y dimension \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
              \n\
        B = d_dinvA;\n\
        C = d_dinvA + blk;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx  ][iny   ] = B[   0*ldb];\n\
            bs[inx  ][iny+ 4] = B[   4*ldb];\n\
            bs[inx  ][iny+ 8] = B[   8*ldb];\n\
"
"\
            bs[inx  ][iny+12] = B[  12*ldb];\n\
            bs[inx+8][iny   ] = B[8+ 0*ldb];\n\
            bs[inx+8][iny+ 4] = B[8+ 4*ldb];\n\
            bs[inx+8][iny+ 8] = B[8+ 8*ldb];\n\
            bs[inx+8][iny+12] = B[8+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
\n\
    //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_32_PART2_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
"
"\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0) * (get_local_size(0)*get_local_size(1));\n\
    const int iby = bIdy * 16;\n\
    const int id = inx + iny*get_local_size(0);\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A22)*A21 -> A21\n\
        // A=inv(A22), B=A21, C=A21\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA + blk*NB + blk;\n\
        B = C = d_dinvA + blk;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx  ][iny   ] = B[   0*ldb];\n\
            bs[inx  ][iny+ 4] = B[   4*ldb];\n\
            bs[inx  ][iny+ 8] = B[   8*ldb];\n\
            bs[inx  ][iny+12] = B[  12*ldb];\n\
            bs[inx+8][iny   ] = B[8+ 0*ldb];\n\
            bs[inx+8][iny+ 4] = B[8+ 4*ldb];\n\
            bs[inx+8][iny+ 8] = B[8+ 8*ldb];\n\
            bs[inx+8][iny+12] = B[8+12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
"
"\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_64_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
"
"\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A12*inv(A22) -> A12(d_dinvA)\n\
        // A=A12, B=inv(A22), C=A12\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + ibx + id ; \n\
        int ya = page*blk*2 + blk ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;   // macro READA will detect overflow on y dimension\n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
\n\
        B = d_dinvA + blk*NB + blk;\n\
        C = d_dinvA + blk*NB;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
"
"\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
#undef READA\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_64_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
"
"\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A11)*A12 -> A12\n\
        // A=inv(A11), B=A12, C=A12\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA;\n\
        B = C = d_dinvA + blk*NB;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
"
"\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_64_PART1_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A21*inv(A11) -> A21\n\
        // A=A21, B=inv(A11), C=A21\n\
"
"\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
        int xa = page*blk*2 + blk + ibx + id ; \n\
        int ya = page*blk*2 ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;  // macro READA will detect overflow on y dimension \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
              \n\
        B = d_dinvA;\n\
        C = d_dinvA + blk;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ; \n\
"
"\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ; \n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ; \n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ; \n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ; \n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
#undef READA\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_64_PART2_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
"
"\
    {\n\
        // -inv(A22)*A21 -> A21\n\
        // A=inv(A22), B=A21, C=A21\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA + blk*NB + blk;\n\
        B = C = d_dinvA + blk;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
"
"\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART1_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A12*inv(A22) -> A12(d_dinvA)\n\
        // A=A12, B=inv(A22), C=A12\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
"
"\
\n\
        int xa = page*blk*2 + ibx + id ; \n\
        int ya = page*blk*2 + blk ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;   // macro READA will detect overflow on y dimension\n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
\n\
        B = d_dinvA + blk*NB + blk;\n\
        C = d_dinvA + blk*NB;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ;\n\
"
"\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
#undef READA\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART1_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
    //--------------------------part one---------------------------//\n\
    {\n\
        // A21*inv(A11) -> A21\n\
        // A=A21, B=inv(A11), C=A21\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
"
"\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        int xa = page*blk*2 + blk + ibx + id ; \n\
        int ya = page*blk*2 ; \n\
        int incA = ya * lda + xa ; \n\
\n\
        // maxA will be used to detect overflow on all subsequent accesses on A(xa, ya:ya+???) \n\
\n\
        int maxA ;\n\
        if ( xa < na ) \n\
          maxA = lda*na ;  // macro READA will detect overflow on y dimension \n\
        else  \n\
          maxA  = 0 ;  // there is already an overflow on xa \n\
\n\
#define READA ( (incA < maxA ) ? Ain[incA] : 0 )  \n\
\n\
        B = d_dinvA;\n\
        C = d_dinvA + blk;\n\
\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4]  ;\n\
            a[0] = READA ; incA += lda ; \n\
            a[1] = READA ; incA += lda ; \n\
            a[2] = READA ; incA += lda ; \n\
            a[3] = READA ; incA += lda ; \n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = READA ; incA += lda ;\n\
"
"\
\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = READA ; incA += lda ;\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = READA ; incA += lda ;\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = READA ; incA += lda ;\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = READA ; incA += lda ;\n\
\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
#undef READA\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A11)*A12*inv(A22)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART2_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A11)*A12 -> A12\n\
        // A=inv(A11), B=A12, C=A12\n\
        __global const double *A;\n\
        __global double *B, *C;\n\
"
"\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA;\n\
        B = d_dinvA + blk*NB;\n\
        C = d_dinvA + blk;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
"
"\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * part 3, copy data into position\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART3_R (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A11)*A12 -> A12\n\
        // A=inv(A11), B=A12, C=A12\n\
        __global double *C_temp, *C_real;\n\
        int ldc = NB;\n\
\n\
        C_temp = d_dinvA + NB*NB*(page/PagesPerNB)\n\
               + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
               + (qmod(page, PagesPerNB))*(blk*2)\n\
               + blk;\n\
\n\
        C_real = d_dinvA + NB*NB*(page/PagesPerNB)\n\
               + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
               + blk*NB\n\
               + (qmod(page, PagesPerNB))*(blk*2);\n\
"
"\
\n\
        C_temp += ibx + id  + __mul( iby, ldc );\n\
        C_real += ibx + id  + __mul( iby, ldc );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C_real[0] = C_temp[0];\n\
            C_temp[0] = ZERO;\n\
            C_temp += ldc;\n\
            C_real += ldc;\n\
        }\n\
    }\n\
}\n\
\n\
/*\n\
 * part 3: copy data back to position\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART3_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part three---------------------------//\n\
    {\n\
        // -inv(A22)*A21 -> A21\n\
        // A=inv(A22), B=A21, C=A21\n\
        __global double *C_temp, *C_real;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        C_real = d_dinvA + blk;\n\
\n\
        C_temp = d_dinvA + blk*NB;\n\
\n\
        C_temp += ibx + id  + __mul( iby, ldc );\n\
        C_real += ibx + id  + __mul( iby, ldc );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
"
"\
            C_real[0] = C_temp[0];\n\
            C_temp[0] = ZERO;\n\
            C_real += ldc;\n\
            C_temp += ldc;\n\
        }\n\
    }\n\
    //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
}\n\
\n\
/*\n\
 * B21 = -inv(A22)*A21*inv(A11)\n\
 */\n\
__kernel void\n\
TRIPLE_DGEMM_UPDATE_ABOVE64_PART2_L (__global const double *Ain, uint offAin, __global double *d_dinvA, int blk, int lda, int npages, int na)\n\
{\n\
    const int bIdy = get_group_id(1)/npages;\n\
    const int page = qmod(get_group_id(1), npages);\n\
    const int inx = get_local_id(0);\n\
    const int iny = get_local_id(1);\n\
    const int ibx = get_group_id(0)*64;\n\
    const int iby = bIdy*16;\n\
    const int id = inx + iny*16;\n\
    __local double bs[16][17];\n\
\n\
    Ain = Ain + offAin;\n\
\n\
    int PagesPerNB = NB/(blk*2);\n\
\n\
    //--------------------------part two---------------------------//\n\
    {\n\
        // -inv(A22)*A21 -> A21\n\
        // A=inv(A22), B=A21, C=A21\n\
        __global double *A, *B, *C;\n\
        int lda = NB;\n\
        int ldb = NB;\n\
        int ldc = NB;\n\
\n\
        d_dinvA += NB*NB*(page/PagesPerNB)\n\
                + (qmod(page, PagesPerNB))*(blk*2)*NB\n\
                + (qmod(page, PagesPerNB))*(blk*2);\n\
\n\
        A = d_dinvA + blk*NB + blk;\n\
        B = d_dinvA + blk;\n\
\n\
        C = d_dinvA + blk*NB;\n\
\n\
        A += ibx + id;\n\
        B += inx + __mul( iby + iny, ldb );\n\
        C += ibx + id  + __mul( iby, ldc );\n\
"
"\
\n\
        __global const double *Blast = B + blk;\n\
\n\
        double c[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\
\n\
        do {\n\
            double a[4] = { A[0*lda], A[1*lda], A[2*lda], A[3*lda] };\n\
\n\
            bs[inx][iny   ] = B[ 0*ldb];\n\
            bs[inx][iny+ 4] = B[ 4*ldb];\n\
            bs[inx][iny+ 8] = B[ 8*ldb];\n\
            bs[inx][iny+12] = B[12*ldb];\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 0][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 1][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 2][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 3][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 4][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 5][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[ 6][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[ 7][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[ 8][0], c );  a[0] = A[0*lda];\n\
            daxpy( a[1], &bs[ 9][0], c );  a[1] = A[1*lda];\n\
            daxpy( a[2], &bs[10][0], c );  a[2] = A[2*lda];\n\
            daxpy( a[3], &bs[11][0], c );  a[3] = A[3*lda];\n\
\n\
            A += 4*lda;\n\
            daxpy( a[0], &bs[12][0], c );\n\
            daxpy( a[1], &bs[13][0], c );\n\
            daxpy( a[2], &bs[14][0], c );\n\
            daxpy( a[3], &bs[15][0], c );\n\
\n\
            B += 16;\n\
            //__syncthreads();\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        } while( B < Blast );\n\
\n\
        for( int i = 0; i < 16; i++ ) {\n\
            C[0] = (-1)*c[i];\n\
            C += ldc;\n\
        }\n\
    }\n\
}\n\
"
"\
\n\
\n\
";



