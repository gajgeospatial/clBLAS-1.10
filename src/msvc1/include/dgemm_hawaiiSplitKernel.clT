static const char * dgemm_NT_8_SPLIT__ALPHABETA = "\
//static const char * dgemm_NT_48_48_8_8x8_6x6__ALPHABETA_SPLIT = "\n\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
\n\
#define  M6x6 \\n\
            rA[0] = lA[offA +  0];                        \\n\
            rA[1] = lA[offA +  1];                        \\n\
            rA[2] = lA[offA + 16];                        \\n\
            rA[3] = lA[offA + 17];                        \\n\
            rA[4] = lA[offA + 32];                        \\n\
            rA[5] = lA[offA + 33];                        \\n\
            rB[0] = lB[offB +  0];                        \\n\
            rB[1] = lB[offB +  1];                        \\n\
            rB[2] = lB[offB + 16];                        \\n\
            rB[3] = lB[offB + 17];                        \\n\
            rB[4] = lB[offB + 32];                        \\n\
            rB[5] = lB[offB + 33];                        \\n\
            offA += 48;                                   \\n\
            offB += 48;                                   \\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);         \\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);         \\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);         \\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);         \\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);         \\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);         \\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);         \\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);         \\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);         \\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);         \\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);         \\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);         \\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);         \\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);         \\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);         \\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);         \\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);         \\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);         \\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);         \\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);         \\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);         \\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);         \\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);         \\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);         \\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);         \\n\
"
"\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);         \\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);         \\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);         \\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);         \\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);         \\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);         \\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);         \\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);         \\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);         \\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);         \\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);         \\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_8_8x8_6x6__ALPHABETA_SPLIT_MAIN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
"
"\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    (C[(offset_x +  0) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  0) * ldc], alpha * rC[0][0]));\n\
    (C[(offset_x +  1) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  0) * ldc], alpha * rC[0][1]));\n\
    (C[(offset_x +  0) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  1) * ldc], alpha * rC[1][0]));\n\
    (C[(offset_x +  1) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  1) * ldc], alpha * rC[1][1]));\n\
    (C[(offset_x +  0) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 16) * ldc], alpha * rC[2][0]));\n\
    (C[(offset_x +  1) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 16) * ldc], alpha * rC[2][1]));\n\
    (C[(offset_x +  0) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 17) * ldc], alpha * rC[3][0]));\n\
    (C[(offset_x +  1) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 17) * ldc], alpha * rC[3][1]));\n\
    (C[(offset_x +  0) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 32) * ldc], alpha * rC[4][0]));\n\
    (C[(offset_x +  1) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 32) * ldc], alpha * rC[4][1]));\n\
    (C[(offset_x +  0) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 33) * ldc], alpha * rC[5][0]));\n\
    (C[(offset_x +  1) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 33) * ldc], alpha * rC[5][1]));\n\
"
"\
    (C[(offset_x + 16) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  0) * ldc], alpha * rC[0][2]));\n\
    (C[(offset_x + 17) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  0) * ldc], alpha * rC[0][3]));\n\
    (C[(offset_x + 16) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  1) * ldc], alpha * rC[1][2]));\n\
    (C[(offset_x + 17) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  1) * ldc], alpha * rC[1][3]));\n\
    (C[(offset_x + 16) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 16) * ldc], alpha * rC[2][2]));\n\
    (C[(offset_x + 17) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 16) * ldc], alpha * rC[2][3]));\n\
    (C[(offset_x + 16) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 17) * ldc], alpha * rC[3][2]));\n\
    (C[(offset_x + 17) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 17) * ldc], alpha * rC[3][3]));\n\
    (C[(offset_x + 16) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 32) * ldc], alpha * rC[4][2]));\n\
    (C[(offset_x + 17) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 32) * ldc], alpha * rC[4][3]));\n\
    (C[(offset_x + 16) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 33) * ldc], alpha * rC[5][2]));\n\
    (C[(offset_x + 17) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 33) * ldc], alpha * rC[5][3]));\n\
    (C[(offset_x + 32) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  0) * ldc], alpha * rC[0][4]));\n\
    (C[(offset_x + 33) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  0) * ldc], alpha * rC[0][5]));\n\
    (C[(offset_x + 32) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  1) * ldc], alpha * rC[1][4]));\n\
    (C[(offset_x + 33) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  1) * ldc], alpha * rC[1][5]));\n\
    (C[(offset_x + 32) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 16) * ldc], alpha * rC[2][4]));\n\
    (C[(offset_x + 33) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 16) * ldc], alpha * rC[2][5]));\n\
    (C[(offset_x + 32) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 17) * ldc], alpha * rC[3][4]));\n\
    (C[(offset_x + 33) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 17) * ldc], alpha * rC[3][5]));\n\
    (C[(offset_x + 32) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 32) * ldc], alpha * rC[4][4]));\n\
    (C[(offset_x + 33) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 32) * ldc], alpha * rC[4][5]));\n\
    (C[(offset_x + 32) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 33) * ldc], alpha * rC[5][4]));\n\
    (C[(offset_x + 33) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 33) * ldc], alpha * rC[5][5]));\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_48_8_8x8_6x6__ALPHABETA_SPLIT_ROW(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
"
"\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    \n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
       __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
       \n\
//        plB[0 ] = uB.d[0 ];\n\
//        plB[1 ] = uB.d[1 ];\n\
//      plB[16] = uB.d[16 ];\n\
//      plB[17] = uB.d[17];\n\
//      plB[32] = uB.d[32];\n\
//        plB[33] = uB.d[33];\n\
\n\
\n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = mad( beta, C[0]     , alpha * rC[0][2*i] );\n\
    C[ldc]    = mad( beta, C[ldc]   , alpha * rC[1][2*i] );\n\
    C[16*ldc] = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
    C[17*ldc] = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
    C[32*ldc] = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
    C[33*ldc] = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        = mad( beta, C[1]     , alpha * rC[0][2*i+1] );\n\
    C[1+ldc]    = mad( beta, C[1+ldc]   , alpha * rC[1][2*i+1] );\n\
    C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
"
"\
  }\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_1_8_8x8_6x6__ALPHABETA_SPLIT_COLUMN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
"
"\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        //plB[0 ] = uB.d2v[0 ];\n\
        //plB[8 ] = uB.d2v[8 ];\n\
        //plB[16] = uB.d2v[16];\n\
       plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
       plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
       plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
       plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
       plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
       plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if( offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]   = mad( beta, C[0], alpha * rC[0][2*i] );\n\
    C[1]   = mad( beta, C[1], alpha * rC[0][2*i+1] );\n\
\n\
    if(offset_y+1<N)\n\
    {\n\
"
"\
      C[ldc]   = mad( beta, C[ldc], alpha * rC[1][2*i] );\n\
      C[1+ldc] = mad( beta, C[1+ldc], alpha * rC[1][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+16<N)\n\
    {\n\
      C[16*ldc]   = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
      C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+17<N)\n\
    {\n\
      C[17*ldc]   = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
      C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+32<N)\n\
    {\n\
      C[32*ldc]   = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
      C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+33<N)\n\
    {\n\
      C[33*ldc]   = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
      C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
    }\n\
\n\
    C+=16;\n\
    \n\
  }\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_8_8x8_6x6__ALPHABETA_SPLIT_SINGLE(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
"
"\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        //plB[0 ] = uB.d2v[0 ];\n\
        //plB[8 ] = uB.d2v[8 ];\n\
        //plB[16] = uB.d2v[16];\n\
        //plA[0 ] = uA.d2v[0 ];\n\
        //plA[8 ] = uA.d2v[8 ];\n\
        //plA[16] = uA.d2v[16];\n\
\n\
       plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
       plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
       plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
       plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
       plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
       plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
\n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
"
"\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = mad( beta, C[0]     , alpha * rC[0][2*i] );\n\
    \n\
    if(offset_y+1<N)\n\
      C[ldc]    = mad( beta, C[ldc]   , alpha * rC[1][2*i] );\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
    if(offset_y+17<N)\n\
      C[17*ldc] = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
    if(offset_y+33<N)\n\
      C[33*ldc] = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
\n\
    if(offset_x+1>=M )\n\
"
"\
      return;\n\
    \n\
    C[1] = mad( beta, C[1]     , alpha * rC[0][2*i+1] );\n\
    \n\
    if(offset_y+1<N)\n\
      C[1+ldc]    = mad( beta, C[1+ldc]   , alpha * rC[1][2*i+1] );\n\
    if(offset_y+16<N)\n\
      C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    if(offset_y+17<N)\n\
      C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    if(offset_y+32<N)\n\
      C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    if(offset_y+33<N)\n\
      C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
";



static const char * dgemm_NT_8_SPLIT__ALPHA = "\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
\n\
#define  M6x6 \\n\
            rA[0] = lA[offA +  0];                        \\n\
            rA[1] = lA[offA +  1];                        \\n\
            rA[2] = lA[offA + 16];                        \\n\
            rA[3] = lA[offA + 17];                        \\n\
            rA[4] = lA[offA + 32];                        \\n\
            rA[5] = lA[offA + 33];                        \\n\
            rB[0] = lB[offB +  0];                        \\n\
            rB[1] = lB[offB +  1];                        \\n\
            rB[2] = lB[offB + 16];                        \\n\
            rB[3] = lB[offB + 17];                        \\n\
            rB[4] = lB[offB + 32];                        \\n\
            rB[5] = lB[offB + 33];                        \\n\
            offA += 48;                                   \\n\
            offB += 48;                                   \\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);         \\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);         \\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);         \\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);         \\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);         \\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);         \\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);         \\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);         \\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);         \\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);         \\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);         \\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);         \\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);         \\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);         \\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);         \\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);         \\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);         \\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);         \\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);         \\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);         \\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);         \\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);         \\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);         \\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);         \\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);         \\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);         \\n\
"
"\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);         \\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);         \\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);         \\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);         \\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);         \\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);         \\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);         \\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);         \\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);         \\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);         \\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_8_8x8_6x6__ALPHA_SPLIT_MAIN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
"
"\
\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    (C[(offset_x +  0) + (offset_y +  0) * ldc] = alpha * rC[0][0]);\n\
    (C[(offset_x +  1) + (offset_y +  0) * ldc] = alpha * rC[0][1]);\n\
    (C[(offset_x +  0) + (offset_y +  1) * ldc] = alpha * rC[1][0]);\n\
    (C[(offset_x +  1) + (offset_y +  1) * ldc] = alpha * rC[1][1]);\n\
    (C[(offset_x +  0) + (offset_y + 16) * ldc] = alpha * rC[2][0]);\n\
    (C[(offset_x +  1) + (offset_y + 16) * ldc] = alpha * rC[2][1]);\n\
    (C[(offset_x +  0) + (offset_y + 17) * ldc] = alpha * rC[3][0]);\n\
    (C[(offset_x +  1) + (offset_y + 17) * ldc] = alpha * rC[3][1]);\n\
    (C[(offset_x +  0) + (offset_y + 32) * ldc] = alpha * rC[4][0]);\n\
    (C[(offset_x +  1) + (offset_y + 32) * ldc] = alpha * rC[4][1]);\n\
    (C[(offset_x +  0) + (offset_y + 33) * ldc] = alpha * rC[5][0]);\n\
    (C[(offset_x +  1) + (offset_y + 33) * ldc] = alpha * rC[5][1]);\n\
    (C[(offset_x + 16) + (offset_y +  0) * ldc] = alpha * rC[0][2]);\n\
    (C[(offset_x + 17) + (offset_y +  0) * ldc] = alpha * rC[0][3]);\n\
"
"\
    (C[(offset_x + 16) + (offset_y +  1) * ldc] = alpha * rC[1][2]);\n\
    (C[(offset_x + 17) + (offset_y +  1) * ldc] = alpha * rC[1][3]);\n\
    (C[(offset_x + 16) + (offset_y + 16) * ldc] = alpha * rC[2][2]);\n\
    (C[(offset_x + 17) + (offset_y + 16) * ldc] = alpha * rC[2][3]);\n\
    (C[(offset_x + 16) + (offset_y + 17) * ldc] = alpha * rC[3][2]);\n\
    (C[(offset_x + 17) + (offset_y + 17) * ldc] = alpha * rC[3][3]);\n\
    (C[(offset_x + 16) + (offset_y + 32) * ldc] = alpha * rC[4][2]);\n\
    (C[(offset_x + 17) + (offset_y + 32) * ldc] = alpha * rC[4][3]);\n\
    (C[(offset_x + 16) + (offset_y + 33) * ldc] = alpha * rC[5][2]);\n\
    (C[(offset_x + 17) + (offset_y + 33) * ldc] = alpha * rC[5][3]);\n\
    (C[(offset_x + 32) + (offset_y +  0) * ldc] = alpha * rC[0][4]);\n\
    (C[(offset_x + 33) + (offset_y +  0) * ldc] = alpha * rC[0][5]);\n\
    (C[(offset_x + 32) + (offset_y +  1) * ldc] = alpha * rC[1][4]);\n\
    (C[(offset_x + 33) + (offset_y +  1) * ldc] = alpha * rC[1][5]);\n\
    (C[(offset_x + 32) + (offset_y + 16) * ldc] = alpha * rC[2][4]);\n\
    (C[(offset_x + 33) + (offset_y + 16) * ldc] = alpha * rC[2][5]);\n\
    (C[(offset_x + 32) + (offset_y + 17) * ldc] = alpha * rC[3][4]);\n\
    (C[(offset_x + 33) + (offset_y + 17) * ldc] = alpha * rC[3][5]);\n\
    (C[(offset_x + 32) + (offset_y + 32) * ldc] = alpha * rC[4][4]);\n\
    (C[(offset_x + 33) + (offset_y + 32) * ldc] = alpha * rC[4][5]);\n\
    (C[(offset_x + 32) + (offset_y + 33) * ldc] = alpha * rC[5][4]);\n\
    (C[(offset_x + 33) + (offset_y + 33) * ldc] = alpha * rC[5][5]);\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_48_8_8x8_6x6__ALPHA_SPLIT_ROW(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
"
"\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
     int CurrentOffSetA = 2*(gidx*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
\n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
"
"\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = alpha * rC[0][2*i] ;\n\
    C[ldc]    = alpha * rC[1][2*i] ;\n\
    C[16*ldc] = alpha * rC[2][2*i] ;\n\
    C[17*ldc] = alpha * rC[3][2*i] ;\n\
    C[32*ldc] = alpha * rC[4][2*i] ;\n\
    C[33*ldc] = alpha * rC[5][2*i] ;\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        =  alpha * rC[0][2*i+1] ;\n\
    C[1+ldc]    =  alpha * rC[1][2*i+1] ;\n\
    C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_1_8_8x8_6x6__ALPHA_SPLIT_COLUMN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
"
"\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*) (lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if( offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]   = alpha * rC[0][2*i] ;\n\
    C[1]   = alpha * rC[0][2*i+1] ;\n\
\n\
    if(offset_y+1<N)\n\
    {\n\
      C[ldc]   =  alpha * rC[1][2*i] ;\n\
      C[1+ldc] =  alpha * rC[1][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+16<N)\n\
    {\n\
      C[16*ldc]   =  alpha * rC[2][2*i] ;\n\
      C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+17<N)\n\
    {\n\
      C[17*ldc]   =  alpha * rC[3][2*i] ;\n\
      C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+32<N)\n\
"
"\
    {\n\
      C[32*ldc]   =  alpha * rC[4][2*i] ;\n\
      C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+33<N)\n\
    {\n\
      C[33*ldc]   =  alpha * rC[5][2*i] ;\n\
      C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
    }\n\
\n\
    C+=16;\n\
    \n\
  }\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_8_8x8_6x6__ALPHA_SPLIT_SINGLE(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
"
"\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        //plB[0 ] = uB.d2v[0 ];\n\
        //plB[8 ] = uB.d2v[8 ];\n\
        //plB[16] = uB.d2v[16];\n\
        //plA[0 ] = uA.d2v[0 ];\n\
        //plA[8 ] = uA.d2v[8 ];\n\
        //plA[16] = uA.d2v[16];\n\
\n\
        \n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
        \n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
"
"\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = alpha * rC[0][2*i] ;\n\
    \n\
    if(offset_y+1<N)\n\
      C[ldc]    =  alpha * rC[1][2*i] ;\n\
    if(offset_y+16<N)\n\
      C[16*ldc] =  alpha * rC[2][2*i] ;\n\
    if(offset_y+17<N)\n\
      C[17*ldc] =  alpha * rC[3][2*i] ;\n\
    if(offset_y+32<N)\n\
      C[32*ldc] =  alpha * rC[4][2*i] ;\n\
    if(offset_y+33<N)\n\
      C[33*ldc] =  alpha * rC[5][2*i] ;\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        =  alpha * rC[0][2*i+1] ;\n\
    if(offset_y+1<N)\n\
      C[1+ldc]    =  alpha * rC[1][2*i+1] ;\n\
    if(offset_y+16<N)\n\
      C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    if(offset_y+17<N)\n\
      C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    if(offset_y+32<N)\n\
      C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    if(offset_y+33<N)\n\
      C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
"
"\
\n\
  }\n\
}\n\
";







static const char * dgemm_NT_1_SPLIT__ALPHABETA = "\
\n\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_1_8x8_6x6__ALPHABETA_SPLIT_MAIN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
"
"\
\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ) ; k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
"
"\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    (C[(offset_x +  0) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  0) * ldc], alpha * rC[0][0]));\n\
    (C[(offset_x +  1) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  0) * ldc], alpha * rC[0][1]));\n\
    (C[(offset_x +  0) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  1) * ldc], alpha * rC[1][0]));\n\
    (C[(offset_x +  1) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  1) * ldc], alpha * rC[1][1]));\n\
    (C[(offset_x +  0) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 16) * ldc], alpha * rC[2][0]));\n\
    (C[(offset_x +  1) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 16) * ldc], alpha * rC[2][1]));\n\
    (C[(offset_x +  0) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 17) * ldc], alpha * rC[3][0]));\n\
    (C[(offset_x +  1) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 17) * ldc], alpha * rC[3][1]));\n\
    (C[(offset_x +  0) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 32) * ldc], alpha * rC[4][0]));\n\
    (C[(offset_x +  1) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 32) * ldc], alpha * rC[4][1]));\n\
    (C[(offset_x +  0) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 33) * ldc], alpha * rC[5][0]));\n\
    (C[(offset_x +  1) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 33) * ldc], alpha * rC[5][1]));\n\
    (C[(offset_x + 16) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  0) * ldc], alpha * rC[0][2]));\n\
    (C[(offset_x + 17) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  0) * ldc], alpha * rC[0][3]));\n\
    (C[(offset_x + 16) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  1) * ldc], alpha * rC[1][2]));\n\
"
"\
    (C[(offset_x + 17) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  1) * ldc], alpha * rC[1][3]));\n\
    (C[(offset_x + 16) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 16) * ldc], alpha * rC[2][2]));\n\
    (C[(offset_x + 17) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 16) * ldc], alpha * rC[2][3]));\n\
    (C[(offset_x + 16) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 17) * ldc], alpha * rC[3][2]));\n\
    (C[(offset_x + 17) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 17) * ldc], alpha * rC[3][3]));\n\
    (C[(offset_x + 16) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 32) * ldc], alpha * rC[4][2]));\n\
    (C[(offset_x + 17) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 32) * ldc], alpha * rC[4][3]));\n\
    (C[(offset_x + 16) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 33) * ldc], alpha * rC[5][2]));\n\
    (C[(offset_x + 17) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 33) * ldc], alpha * rC[5][3]));\n\
    (C[(offset_x + 32) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  0) * ldc], alpha * rC[0][4]));\n\
    (C[(offset_x + 33) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  0) * ldc], alpha * rC[0][5]));\n\
    (C[(offset_x + 32) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  1) * ldc], alpha * rC[1][4]));\n\
    (C[(offset_x + 33) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  1) * ldc], alpha * rC[1][5]));\n\
    (C[(offset_x + 32) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 16) * ldc], alpha * rC[2][4]));\n\
    (C[(offset_x + 33) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 16) * ldc], alpha * rC[2][5]));\n\
    (C[(offset_x + 32) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 17) * ldc], alpha * rC[3][4]));\n\
    (C[(offset_x + 33) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 17) * ldc], alpha * rC[3][5]));\n\
    (C[(offset_x + 32) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 32) * ldc], alpha * rC[4][4]));\n\
    (C[(offset_x + 33) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 32) * ldc], alpha * rC[4][5]));\n\
    (C[(offset_x + 32) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 33) * ldc], alpha * rC[5][4]));\n\
    (C[(offset_x + 33) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 33) * ldc], alpha * rC[5][5]));\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_48_1_8x8_6x6__ALPHABETA_SPLIT_ROW(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
"
"\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
    \n\
      uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double* plA =(lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
               \n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
"
"\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
"
"\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = mad( beta, C[0]     , alpha * rC[0][2*i] );\n\
    C[ldc]    = mad( beta, C[ldc]   , alpha * rC[1][2*i] );\n\
    C[16*ldc] = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
    C[17*ldc] = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
    C[32*ldc] = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
    C[33*ldc] = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        = mad( beta, C[1]     , alpha * rC[0][2*i+1] );\n\
    C[1+ldc]    = mad( beta, C[1+ldc]   , alpha * rC[1][2*i+1] );\n\
    C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_1_1_8x8_6x6__ALPHABETA_SPLIT_COLUMN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
"
"\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
"
"\
        int offB = idy << 1;\n\
                #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
"
"\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if( offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]   = mad( beta, C[0], alpha * rC[0][2*i] );\n\
    C[1]   = mad( beta, C[1], alpha * rC[0][2*i+1] );\n\
\n\
    if(offset_y+1<N)\n\
    {\n\
      C[ldc]   = mad( beta, C[ldc], alpha * rC[1][2*i] );\n\
      C[1+ldc] = mad( beta, C[1+ldc], alpha * rC[1][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+16<N)\n\
    {\n\
      C[16*ldc]   = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
      C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+17<N)\n\
    {\n\
      C[17*ldc]   = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
      C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+32<N)\n\
    {\n\
      C[32*ldc]   = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
"
"\
      C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    }\n\
\n\
    if(offset_y+33<N)\n\
    {\n\
      C[33*ldc]   = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
      C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
    }\n\
\n\
    C+=16;\n\
    \n\
  }\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_1_8x8_6x6__ALPHABETA_SPLIT_SINGLE(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
"
"\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
        \n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
                #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
"
"\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
"
"\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = mad( beta, C[0]     , alpha * rC[0][2*i] );\n\
    \n\
    if(offset_y+1<N)\n\
      C[ldc]    = mad( beta, C[ldc]   , alpha * rC[1][2*i] );\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad( beta, C[16*ldc], alpha * rC[2][2*i] );\n\
    if(offset_y+17<N)\n\
      C[17*ldc] = mad( beta, C[17*ldc], alpha * rC[3][2*i] );\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad( beta, C[32*ldc], alpha * rC[4][2*i] );\n\
    if(offset_y+33<N)\n\
      C[33*ldc] = mad( beta, C[33*ldc], alpha * rC[5][2*i] );\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1] = mad( beta, C[1]     , alpha * rC[0][2*i+1] );\n\
    \n\
    if(offset_y+1<N)\n\
      C[1+ldc]    = mad( beta, C[1+ldc]   , alpha * rC[1][2*i+1] );\n\
    if(offset_y+16<N)\n\
      C[1+16*ldc] = mad( beta, C[1+16*ldc], alpha * rC[2][2*i+1] );\n\
    if(offset_y+17<N)\n\
      C[1+17*ldc] = mad( beta, C[1+17*ldc], alpha * rC[3][2*i+1] );\n\
    if(offset_y+32<N)\n\
      C[1+32*ldc] = mad( beta, C[1+32*ldc], alpha * rC[4][2*i+1] );\n\
    if(offset_y+33<N)\n\
      C[1+33*ldc] = mad( beta, C[1+33*ldc], alpha * rC[5][2*i+1] );\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
";



static const char * dgemm_NT_1_SPLIT__ALPHA = "\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
\n\
#define  M6x6 \\n\
            rA[0] = lA[offA +  0];                        \\n\
            rA[1] = lA[offA +  1];                        \\n\
            rA[2] = lA[offA + 16];                        \\n\
            rA[3] = lA[offA + 17];                        \\n\
            rA[4] = lA[offA + 32];                        \\n\
            rA[5] = lA[offA + 33];                        \\n\
            rB[0] = lB[offB +  0];                        \\n\
            rB[1] = lB[offB +  1];                        \\n\
            rB[2] = lB[offB + 16];                        \\n\
            rB[3] = lB[offB + 17];                        \\n\
            rB[4] = lB[offB + 32];                        \\n\
            rB[5] = lB[offB + 33];                        \\n\
            offA += 48;                                   \\n\
            offB += 48;                                   \\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);         \\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);         \\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);         \\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);         \\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);         \\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);         \\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);         \\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);         \\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);         \\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);         \\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);         \\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);         \\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);         \\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);         \\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);         \\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);         \\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);         \\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);         \\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);         \\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);         \\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);         \\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);         \\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);         \\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);         \\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);         \\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);         \\n\
"
"\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);         \\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);         \\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);         \\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);         \\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);         \\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);         \\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);         \\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);         \\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);         \\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);         \\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_1_8x8_6x6__ALPHA_SPLIT_MAIN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
"
"\
\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
                #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
"
"\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    (C[(offset_x +  0) + (offset_y +  0) * ldc] = alpha * rC[0][0]);\n\
    (C[(offset_x +  1) + (offset_y +  0) * ldc] = alpha * rC[0][1]);\n\
    (C[(offset_x +  0) + (offset_y +  1) * ldc] = alpha * rC[1][0]);\n\
    (C[(offset_x +  1) + (offset_y +  1) * ldc] = alpha * rC[1][1]);\n\
    (C[(offset_x +  0) + (offset_y + 16) * ldc] = alpha * rC[2][0]);\n\
    (C[(offset_x +  1) + (offset_y + 16) * ldc] = alpha * rC[2][1]);\n\
    (C[(offset_x +  0) + (offset_y + 17) * ldc] = alpha * rC[3][0]);\n\
    (C[(offset_x +  1) + (offset_y + 17) * ldc] = alpha * rC[3][1]);\n\
    (C[(offset_x +  0) + (offset_y + 32) * ldc] = alpha * rC[4][0]);\n\
    (C[(offset_x +  1) + (offset_y + 32) * ldc] = alpha * rC[4][1]);\n\
    (C[(offset_x +  0) + (offset_y + 33) * ldc] = alpha * rC[5][0]);\n\
    (C[(offset_x +  1) + (offset_y + 33) * ldc] = alpha * rC[5][1]);\n\
    (C[(offset_x + 16) + (offset_y +  0) * ldc] = alpha * rC[0][2]);\n\
    (C[(offset_x + 17) + (offset_y +  0) * ldc] = alpha * rC[0][3]);\n\
    (C[(offset_x + 16) + (offset_y +  1) * ldc] = alpha * rC[1][2]);\n\
"
"\
    (C[(offset_x + 17) + (offset_y +  1) * ldc] = alpha * rC[1][3]);\n\
    (C[(offset_x + 16) + (offset_y + 16) * ldc] = alpha * rC[2][2]);\n\
    (C[(offset_x + 17) + (offset_y + 16) * ldc] = alpha * rC[2][3]);\n\
    (C[(offset_x + 16) + (offset_y + 17) * ldc] = alpha * rC[3][2]);\n\
    (C[(offset_x + 17) + (offset_y + 17) * ldc] = alpha * rC[3][3]);\n\
    (C[(offset_x + 16) + (offset_y + 32) * ldc] = alpha * rC[4][2]);\n\
    (C[(offset_x + 17) + (offset_y + 32) * ldc] = alpha * rC[4][3]);\n\
    (C[(offset_x + 16) + (offset_y + 33) * ldc] = alpha * rC[5][2]);\n\
    (C[(offset_x + 17) + (offset_y + 33) * ldc] = alpha * rC[5][3]);\n\
    (C[(offset_x + 32) + (offset_y +  0) * ldc] = alpha * rC[0][4]);\n\
    (C[(offset_x + 33) + (offset_y +  0) * ldc] = alpha * rC[0][5]);\n\
    (C[(offset_x + 32) + (offset_y +  1) * ldc] = alpha * rC[1][4]);\n\
    (C[(offset_x + 33) + (offset_y +  1) * ldc] = alpha * rC[1][5]);\n\
    (C[(offset_x + 32) + (offset_y + 16) * ldc] = alpha * rC[2][4]);\n\
    (C[(offset_x + 33) + (offset_y + 16) * ldc] = alpha * rC[2][5]);\n\
    (C[(offset_x + 32) + (offset_y + 17) * ldc] = alpha * rC[3][4]);\n\
    (C[(offset_x + 33) + (offset_y + 17) * ldc] = alpha * rC[3][5]);\n\
    (C[(offset_x + 32) + (offset_y + 32) * ldc] = alpha * rC[4][4]);\n\
    (C[(offset_x + 33) + (offset_y + 32) * ldc] = alpha * rC[4][5]);\n\
    (C[(offset_x + 32) + (offset_y + 33) * ldc] = alpha * rC[5][4]);\n\
    (C[(offset_x + 33) + (offset_y + 33) * ldc] = alpha * rC[5][5]);\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_48_1_8x8_6x6__ALPHA_SPLIT_ROW(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
"
"\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double2* plB = (__local double2*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = uB.d2v[0 ];\n\
        plB[8 ] = uB.d2v[8 ];\n\
        plB[16] = uB.d2v[16];\n\
\n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
                #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
"
"\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
"
"\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = alpha * rC[0][2*i] ;\n\
    C[ldc]    = alpha * rC[1][2*i] ;\n\
    C[16*ldc] = alpha * rC[2][2*i] ;\n\
    C[17*ldc] = alpha * rC[3][2*i] ;\n\
    C[32*ldc] = alpha * rC[4][2*i] ;\n\
    C[33*ldc] = alpha * rC[5][2*i] ;\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        =  alpha * rC[0][2*i+1] ;\n\
    C[1+ldc]    =  alpha * rC[1][2*i+1] ;\n\
    C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_1_1_8x8_6x6__ALPHA_SPLIT_COLUMN(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
"
"\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double2* plA = (__local double2*)(lA + idy*48 + 2*idx);\n\
        __local double* plB = (__local double*)(lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
        \n\
        plA[0 ] = uA.d2v[0 ];\n\
        plA[8 ] = uA.d2v[8 ];\n\
        plA[16] = uA.d2v[16];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
       \n\
"
"\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
"
"\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if( offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]   = alpha * rC[0][2*i] ;\n\
    C[1]   = alpha * rC[0][2*i+1] ;\n\
\n\
    if(offset_y+1<N)\n\
    {\n\
      C[ldc]   =  alpha * rC[1][2*i] ;\n\
      C[1+ldc] =  alpha * rC[1][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+16<N)\n\
    {\n\
      C[16*ldc]   =  alpha * rC[2][2*i] ;\n\
      C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+17<N)\n\
    {\n\
      C[17*ldc]   =  alpha * rC[3][2*i] ;\n\
      C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    }\n\
\n\
    if(offset_y+32<N)\n\
    {\n\
      C[32*ldc]   =  alpha * rC[4][2*i] ;\n\
      C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    }\n\
"
"\
\n\
    if(offset_y+33<N)\n\
    {\n\
      C[33*ldc]   =  alpha * rC[5][2*i] ;\n\
      C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
    }\n\
\n\
    C+=16;\n\
    \n\
  }\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_1_8x8_6x6__ALPHA_SPLIT_SINGLE(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
"
"\
\n\
    int CurrentOffSetA = 2*(gidx*24 + idx);\n\
    int CurrentOffSetB = 2*(gidy*24 + idx);\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
        __local double* plA = (lA + idy*48 + 2*idx);\n\
        __local double* plB = (lB + idy*48 + 2*idx);\n\
//        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0 ] = CurrentOffSetB>=N?0.0:uB.d[0 ];\n\
        plB[1 ] = CurrentOffSetB+1>=N?0.0:uB.d[1 ];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:uB.d[16 ];\n\
        plB[17] = CurrentOffSetB+17>=N?0.0:uB.d[17];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:uB.d[32];\n\
        plB[33] = CurrentOffSetB+33>=N?0.0:uB.d[33];\n\
        \n\
        plA[0]  =  CurrentOffSetA>=M?0.0:uA.d[0];\n\
        plA[1]  =  CurrentOffSetA+1>=M?0.0:uA.d[1];\n\
        plA[16] =  CurrentOffSetA+16>=M?0.0:uA.d[16];\n\
        plA[17] =  CurrentOffSetA+17>=M?0.0:uA.d[17];\n\
        plA[32] =  CurrentOffSetA+32>=M?0.0:uA.d[32];\n\
        plA[33] =  CurrentOffSetA+33>=M?0.0:uA.d[33];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
             \n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < min(8u, K-block_k ); k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
"
"\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
"
"\
  C+=offset_x+offset_y*ldc;\n\
\n\
\n\
  for (int i = 0; i<3; i++)\n\
  {\n\
    C[0]      = alpha * rC[0][2*i] ;\n\
    \n\
    if(offset_y+1<N)\n\
      C[ldc]    =  alpha * rC[1][2*i] ;\n\
    if(offset_y+16<N)\n\
      C[16*ldc] =  alpha * rC[2][2*i] ;\n\
    if(offset_y+17<N)\n\
      C[17*ldc] =  alpha * rC[3][2*i] ;\n\
    if(offset_y+32<N)\n\
      C[32*ldc] =  alpha * rC[4][2*i] ;\n\
    if(offset_y+33<N)\n\
      C[33*ldc] =  alpha * rC[5][2*i] ;\n\
\n\
    if(offset_x+1>=M )\n\
      return;\n\
    \n\
    C[1]        =  alpha * rC[0][2*i+1] ;\n\
    if(offset_y+1<N)\n\
      C[1+ldc]    =  alpha * rC[1][2*i+1] ;\n\
    if(offset_y+16<N)\n\
      C[1+16*ldc] =  alpha * rC[2][2*i+1] ;\n\
    if(offset_y+17<N)\n\
      C[1+17*ldc] =  alpha * rC[3][2*i+1] ;\n\
    if(offset_y+32<N)\n\
      C[1+32*ldc] =  alpha * rC[4][2*i+1] ;\n\
    if(offset_y+33<N)\n\
      C[1+33*ldc] =  alpha * rC[5][2*i+1] ;\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
       return;\n\
\n\
  }\n\
}\n\
";




static const char * dgemm_NN_8_SPLIT__ALPHABETA = "\
\n\
\n\
\n\
#define  M6x6 \\n\
            rA[0] = lA[offA + 0];                       \\n\
            rA[1] = lA[offA + 8];                       \\n\
            rA[2] = lA[offA + 16];                      \\n\
            rA[3] = lA[offA + 24];                      \\n\
            rA[4] = lA[offA + 32];                      \\n\
            rA[5] = lA[offA + 40];                      \\n\
            rB[0] = lB[offB + 0];                       \\n\
            rB[1] = lB[offB + 8];                       \\n\
            rB[2] = lB[offB + 16];                      \\n\
            rB[3] = lB[offB + 24];                      \\n\
            rB[4] = lB[offB + 32];                      \\n\
            rB[5] = lB[offB + 40];                      \\n\
            offA += 49;                                 \\n\
            offB += 49;                                 \\n\
            rC[0][0]=mad(rA[0],rB[0],rC[0][0]);         \\n\
            rC[1][0]=mad(rA[1],rB[0],rC[1][0]);         \\n\
            rC[2][0]=mad(rA[2],rB[0],rC[2][0]);         \\n\
            rC[3][0]=mad(rA[3],rB[0],rC[3][0]);         \\n\
            rC[4][0]=mad(rA[4],rB[0],rC[4][0]);         \\n\
            rC[5][0]=mad(rA[5],rB[0],rC[5][0]);         \\n\
            rC[0][1]=mad(rA[0],rB[1],rC[0][1]);         \\n\
            rC[1][1]=mad(rA[1],rB[1],rC[1][1]);         \\n\
            rC[2][1]=mad(rA[2],rB[1],rC[2][1]);         \\n\
            rC[3][1]=mad(rA[3],rB[1],rC[3][1]);         \\n\
            rC[4][1]=mad(rA[4],rB[1],rC[4][1]);         \\n\
            rC[5][1]=mad(rA[5],rB[1],rC[5][1]);         \\n\
            rC[0][2]=mad(rA[0],rB[2],rC[0][2]);         \\n\
            rC[1][2]=mad(rA[1],rB[2],rC[1][2]);         \\n\
            rC[2][2]=mad(rA[2],rB[2],rC[2][2]);         \\n\
            rC[3][2]=mad(rA[3],rB[2],rC[3][2]);         \\n\
            rC[4][2]=mad(rA[4],rB[2],rC[4][2]);         \\n\
            rC[5][2]=mad(rA[5],rB[2],rC[5][2]);         \\n\
            rC[0][3]=mad(rA[0],rB[3],rC[0][3]);         \\n\
            rC[1][3]=mad(rA[1],rB[3],rC[1][3]);         \\n\
            rC[2][3]=mad(rA[2],rB[3],rC[2][3]);         \\n\
            rC[3][3]=mad(rA[3],rB[3],rC[3][3]);         \\n\
            rC[4][3]=mad(rA[4],rB[3],rC[4][3]);         \\n\
            rC[5][3]=mad(rA[5],rB[3],rC[5][3]);         \\n\
            rC[0][4]=mad(rA[0],rB[4],rC[0][4]);         \\n\
            rC[1][4]=mad(rA[1],rB[4],rC[1][4]);         \\n\
            rC[2][4]=mad(rA[2],rB[4],rC[2][4]);         \\n\
            rC[3][4]=mad(rA[3],rB[4],rC[3][4]);         \\n\
            rC[4][4]=mad(rA[4],rB[4],rC[4][4]);         \\n\
            rC[5][4]=mad(rA[5],rB[4],rC[5][4]);         \\n\
            rC[0][5]=mad(rA[0],rB[5],rC[0][5]);         \\n\
"
"\
            rC[1][5]=mad(rA[1],rB[5],rC[1][5]);         \\n\
            rC[2][5]=mad(rA[2],rB[5],rC[2][5]);         \\n\
            rC[3][5]=mad(rA[3],rB[5],rC[3][5]);         \\n\
            rC[4][5]=mad(rA[4],rB[5],rC[4][5]);         \\n\
            rC[5][5]=mad(rA[5],rB[5],rC[5][5]);         \\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_48_8_8x8_6x6__ALPHABETA_SPLIT_MAIN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
"
"\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
"
"\
  C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[0][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[1][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[2][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[3][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[4][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[5][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[5][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[5][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[5][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[5][5] + beta*C[40*ldc];\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_48_8_8x8_6x6__ALPHABETA_SPLIT_ROW(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
"
"\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
 \n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
   \n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
    \n\
       \n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
"
"\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] + beta*C[0*ldc+i*8];\n\
    C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
    \n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
  }while (++i < 6);\n\
  \n\
}\n\
"
"\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_1_8_8x8_6x6__ALPHABETA_SPLIT_COLUMN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  (gidy*48+idyT)*ldb + idxT;\n\
\n\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
"
"\
\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[i*8]  = alpha*rC[i][0] + beta*C[i*8];\n\
    \n\
"
"\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
\n\
  }while (++i < 6);\n\
\n\
\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_1_8_8x8_6x6__ALPHABETA_SPLIT_SINGLE(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
"
"\
    int gidx = M/48;//get_group_id(0);\n\
    int gidy = N/48;//get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
\n\
\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
 \n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  (gidy*48+idyT)*ldb + idxT;\n\
\n\
  __local double* plA = lA + idyT*49 + idxT;\n\
  __local double* plB = lB + idxT*49 + idyT;\n\
\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[40*ldb];\n\
\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
"
"\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
\n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] + beta*C[0*ldc+i*8];\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
\n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
";



static const char * dgemm_NN_8_SPLIT__ALPHA = "\
\n\
\n\
\n\
#define  M6x6 \\n\
            rA[0] = lA[offA + 0];\\n\
            rA[1] = lA[offA + 8];\\n\
            rA[2] = lA[offA + 16];\\n\
            rA[3] = lA[offA + 24];\\n\
            rA[4] = lA[offA + 32];\\n\
            rA[5] = lA[offA + 40];\\n\
            rB[0] = lB[offB + 0];\\n\
            rB[1] = lB[offB + 8];\\n\
            rB[2] = lB[offB + 16];\\n\
            rB[3] = lB[offB + 24]; \\n\
            rB[4] = lB[offB + 32]; \\n\
            rB[5] = lB[offB + 40]; \\n\
            offA += 49; \\n\
            offB += 49; \\n\
            rC[0][0]=mad(rA[0],rB[0],rC[0][0]);         \\n\
            rC[1][0]=mad(rA[1],rB[0],rC[1][0]);         \\n\
            rC[2][0]=mad(rA[2],rB[0],rC[2][0]);         \\n\
            rC[3][0]=mad(rA[3],rB[0],rC[3][0]);         \\n\
            rC[4][0]=mad(rA[4],rB[0],rC[4][0]);         \\n\
            rC[5][0]=mad(rA[5],rB[0],rC[5][0]);         \\n\
            rC[0][1]=mad(rA[0],rB[1],rC[0][1]);         \\n\
            rC[1][1]=mad(rA[1],rB[1],rC[1][1]);         \\n\
            rC[2][1]=mad(rA[2],rB[1],rC[2][1]);         \\n\
            rC[3][1]=mad(rA[3],rB[1],rC[3][1]);         \\n\
            rC[4][1]=mad(rA[4],rB[1],rC[4][1]);         \\n\
            rC[5][1]=mad(rA[5],rB[1],rC[5][1]);         \\n\
            rC[0][2]=mad(rA[0],rB[2],rC[0][2]);         \\n\
            rC[1][2]=mad(rA[1],rB[2],rC[1][2]);         \\n\
            rC[2][2]=mad(rA[2],rB[2],rC[2][2]);         \\n\
            rC[3][2]=mad(rA[3],rB[2],rC[3][2]);         \\n\
            rC[4][2]=mad(rA[4],rB[2],rC[4][2]);         \\n\
            rC[5][2]=mad(rA[5],rB[2],rC[5][2]);         \\n\
            rC[0][3]=mad(rA[0],rB[3],rC[0][3]);         \\n\
            rC[1][3]=mad(rA[1],rB[3],rC[1][3]);         \\n\
            rC[2][3]=mad(rA[2],rB[3],rC[2][3]);         \\n\
            rC[3][3]=mad(rA[3],rB[3],rC[3][3]);         \\n\
            rC[4][3]=mad(rA[4],rB[3],rC[4][3]);         \\n\
            rC[5][3]=mad(rA[5],rB[3],rC[5][3]);         \\n\
            rC[0][4]=mad(rA[0],rB[4],rC[0][4]);         \\n\
            rC[1][4]=mad(rA[1],rB[4],rC[1][4]);         \\n\
            rC[2][4]=mad(rA[2],rB[4],rC[2][4]);         \\n\
            rC[3][4]=mad(rA[3],rB[4],rC[3][4]);         \\n\
            rC[4][4]=mad(rA[4],rB[4],rC[4][4]);         \\n\
            rC[5][4]=mad(rA[5],rB[4],rC[5][4]);         \\n\
            rC[0][5]=mad(rA[0],rB[5],rC[0][5]);         \\n\
"
"\
            rC[1][5]=mad(rA[1],rB[5],rC[1][5]);         \\n\
            rC[2][5]=mad(rA[2],rB[5],rC[2][5]);         \\n\
            rC[3][5]=mad(rA[3],rB[5],rC[3][5]);         \\n\
            rC[4][5]=mad(rA[4],rB[5],rC[4][5]);         \\n\
            rC[5][5]=mad(rA[5],rB[5],rC[5][5]);         \\n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_48_8_8x8_6x6__ALPHA_SPLIT_MAIN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
    int block_k = K >> 3;\n\
"
"\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0]  ;\n\
  C[8*ldc] = alpha*rC[0][1]  ;\n\
  C[16*ldc] = alpha*rC[0][2] ;\n\
  C[24*ldc] = alpha*rC[0][3] ;\n\
  C[32*ldc] = alpha*rC[0][4] ;\n\
  C[40*ldc] = alpha*rC[0][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[1][0]  ;\n\
  C[8*ldc] = alpha*rC[1][1]  ;\n\
  C[16*ldc] = alpha*rC[1][2] ;\n\
  C[24*ldc] = alpha*rC[1][3] ;\n\
"
"\
  C[32*ldc] = alpha*rC[1][4] ;\n\
  C[40*ldc] = alpha*rC[1][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[2][0]  ;\n\
  C[8*ldc] = alpha*rC[2][1]  ;\n\
  C[16*ldc] = alpha*rC[2][2] ;\n\
  C[24*ldc] = alpha*rC[2][3] ;\n\
  C[32*ldc] = alpha*rC[2][4] ;\n\
  C[40*ldc] = alpha*rC[2][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[3][0]  ;\n\
  C[8*ldc] = alpha*rC[3][1]  ;\n\
  C[16*ldc] = alpha*rC[3][2] ;\n\
  C[24*ldc] = alpha*rC[3][3] ;\n\
  C[32*ldc] = alpha*rC[3][4] ;\n\
  C[40*ldc] = alpha*rC[3][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[4][0]  ;\n\
  C[8*ldc] = alpha*rC[4][1]  ;\n\
  C[16*ldc] = alpha*rC[4][2] ;\n\
  C[24*ldc] = alpha*rC[4][3] ;\n\
  C[32*ldc] = alpha*rC[4][4] ;\n\
  C[40*ldc] = alpha*rC[4][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[5][0]  ;\n\
  C[8*ldc] = alpha*rC[5][1]  ;\n\
  C[16*ldc] = alpha*rC[5][2] ;\n\
  C[24*ldc] = alpha*rC[5][3] ;\n\
  C[32*ldc] = alpha*rC[5][4] ;\n\
  C[40*ldc] = alpha*rC[5][5] ;\n\
  \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_48_8_8x8_6x6__ALPHA_SPLIT_ROW(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
"
"\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  \n\
int CurrentOffSetA =   gidx*48 + idxT;\n\
  \n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        \n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
         plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
        \n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  for (int i=0; i<6; i++)\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] ;\n\
    C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    C[24*ldc+i*8] = alpha*rC[i][3] ;\n\
    C[32*ldc+i*8] = alpha*rC[i][4] ;\n\
    C[40*ldc+i*8] = alpha*rC[i][5] ;\n\
    \n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
  }\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_1_8_8x8_6x6__ALPHA_SPLIT_COLUMN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
"
"\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
   int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
        plA[0] = A[0+0*lda];\n\
"
"\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        \n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0]   ;\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3] ;\n\
    \n\
    if (offset_y+32<N)\n\
"
"\
      C[32*ldc+i*8] = alpha*rC[i][4] ;\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5] ;\n\
\n\
\n\
\n\
  }while (++i < 6);\n\
  \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_1_8_8x8_6x6__ALPHA_SPLIT_SINGLE(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C  += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  \n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
"
"\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
    int block_k = K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        A += lda << 3;\n\
        B += 8;\n\
    } while (--block_k > 0);\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
"
"\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0]  ;\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5];\n\
\n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
\n\
  }while (++i < 6);\n\
  \n\
}\n\
";







static const char * dgemm_NN_1_SPLIT__ALPHABETA = "\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_48_1_8x8_6x6__ALPHABETA_SPLIT_MAIN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
"
"\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        \n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        \n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
"
"\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
\n\
\n\
        A += lda << 3;\n\
        B += 8;    \n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
"
"\
  C[40*ldc] = alpha*rC[0][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[1][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[2][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[3][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[4][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[5][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[5][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[5][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[5][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[5][5] + beta*C[40*ldc];\n\
  \n\
 }\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_48_1_8x8_6x6__ALPHABETA_SPLIT_ROW(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
"
"\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
   \n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        \n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
"
"\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
"
"\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M  )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] + beta*C[0*ldc+i*8];\n\
    \n\
      C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    \n\
      C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    \n\
      C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    \n\
      C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    \n\
      C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
\n\
"
"\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
  }while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_1_1_8x8_6x6__ALPHABETA_SPLIT_COLUMN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
"
"\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        \n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
"
"\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if( offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] + beta*C[0*ldc+i*8];\n\
"
"\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_1_1_8x8_6x6__ALPHABETA_SPLIT_SINGLE(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
"
"\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = N/48; //get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
"
"\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
"
"\
        B += 8;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0] + beta*C[0*ldc+i*8];\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] + beta*C[8*ldc+i*8];\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] + beta*C[16*ldc+i*8];\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3] + beta*C[24*ldc+i*8];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4] + beta*C[32*ldc+i*8];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5] + beta*C[40*ldc+i*8];\n\
\n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
";



static const char * dgemm_NN_1_SPLIT__ALPHA = "\
\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_48_1_8x8_6x6__ALPHA_SPLIT_MAIN(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
"
"\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
"
"\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;\n\
        block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0]  ;\n\
  C[8*ldc] = alpha*rC[0][1]  ;\n\
  C[16*ldc] = alpha*rC[0][2] ;\n\
  C[24*ldc] = alpha*rC[0][3] ;\n\
  C[32*ldc] = alpha*rC[0][4] ;\n\
  C[40*ldc] = alpha*rC[0][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[1][0]  ;\n\
  C[8*ldc] = alpha*rC[1][1]  ;\n\
  C[16*ldc] = alpha*rC[1][2] ;\n\
  C[24*ldc] = alpha*rC[1][3] ;\n\
"
"\
  C[32*ldc] = alpha*rC[1][4] ;\n\
  C[40*ldc] = alpha*rC[1][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[2][0]  ;\n\
  C[8*ldc] = alpha*rC[2][1]  ;\n\
  C[16*ldc] = alpha*rC[2][2] ;\n\
  C[24*ldc] = alpha*rC[2][3] ;\n\
  C[32*ldc] = alpha*rC[2][4] ;\n\
  C[40*ldc] = alpha*rC[2][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[3][0]  ;\n\
  C[8*ldc] = alpha*rC[3][1]  ;\n\
  C[16*ldc] = alpha*rC[3][2] ;\n\
  C[24*ldc] = alpha*rC[3][3] ;\n\
  C[32*ldc] = alpha*rC[3][4] ;\n\
  C[40*ldc] = alpha*rC[3][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[4][0]  ;\n\
  C[8*ldc] = alpha*rC[4][1]  ;\n\
  C[16*ldc] = alpha*rC[4][2] ;\n\
  C[24*ldc] = alpha*rC[4][3] ;\n\
  C[32*ldc] = alpha*rC[4][4] ;\n\
  C[40*ldc] = alpha*rC[4][5] ;\n\
  C+=8;                         ;\n\
  C[0*ldc] = alpha*rC[5][0]  ;\n\
  C[8*ldc] = alpha*rC[5][1]  ;\n\
  C[16*ldc] = alpha*rC[5][2] ;\n\
  C[24*ldc] = alpha*rC[5][3] ;\n\
  C[32*ldc] = alpha*rC[5][4] ;\n\
  C[40*ldc] = alpha*rC[5][5] ;\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_48_1_8x8_6x6__ALPHA_SPLIT_ROW(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
\n\
    A += offsetA;\n\
"
"\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        \n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
"
"\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0]  ;\n\
    \n\
      C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    \n\
      C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    \n\
      C[24*ldc+i*8] = alpha*rC[i][3];\n\
    \n\
      C[32*ldc+i*8] = alpha*rC[i][4];\n\
    \n\
      C[40*ldc+i*8] = alpha*rC[i][5];\n\
\n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_48_1_1_8x8_6x6__ALPHA_SPLIT_COLUMN(__global double const * restrict A,\n\
"
"\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
   int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
"
"\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[8+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[24] = A[24+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[40] = A[40+0*lda];\n\
        \n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
"
"\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_y>=N )\n\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0]  ;\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    \n\
    if (offset_y+24<N)\n\
"
"\
      C[24*ldc+i*8] = alpha*rC[i][3];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5];\n\
\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NN_1_1_1_8x8_6x6__ALPHA_SPLIT_SINGLE(__global double const * restrict A,\n\
                                       __global double const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
  \n\
  int gidx = M/48;//get_group_id(0);\n\
  int gidy = N/48;//get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
"
"\
  int CurrentOffSetA =   gidx*48 + idxT;\n\
  int CurrentOffSetB =   gidy*48 + idyT;\n\
\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
\n\
\n\
\n\
    int block_k = 0;//K >> 3;\n\
    do {\n\
\n\
        __local double* plA = lA + idyT*49 + idxT;\n\
        __local double* plB = lB + idxT*49 + idyT;\n\
\n\
        \n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8]  = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[0+16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[0+32*ldb];\n\
        plB[40] = CurrentOffSetB+40>=N?0.0:B[0+40*ldb];\n\
\n\
\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[40] = CurrentOffSetA+40>=M?0.0:A[40];\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx ;\n\
        int offB = idy ;\n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k <min(8u, K-block_k ); k+=1)\n\
        {\n\
          rA[0] = lA[offA + 0];               \n\
          rA[1] = lA[offA + 8];               \n\
          rA[2] = lA[offA + 16];              \n\
          rA[3] = lA[offA + 24];              \n\
          rA[4] = lA[offA + 32];              \n\
          rA[5] = lA[offA + 40];              \n\
          rB[0] = lB[offB + 0];               \n\
          rB[1] = lB[offB + 8];               \n\
          rB[2] = lB[offB + 16];              \n\
          rB[3] = lB[offB + 24];              \n\
          rB[4] = lB[offB + 32];              \n\
          rB[5] = lB[offB + 40];              \n\
"
"\
          offA += 49;                         \n\
          offB += 49;                         \n\
          rC[0][0]=mad(rA[0],rB[0],rC[0][0]); \n\
          rC[1][0]=mad(rA[1],rB[0],rC[1][0]); \n\
          rC[2][0]=mad(rA[2],rB[0],rC[2][0]); \n\
          rC[3][0]=mad(rA[3],rB[0],rC[3][0]); \n\
          rC[4][0]=mad(rA[4],rB[0],rC[4][0]); \n\
          rC[5][0]=mad(rA[5],rB[0],rC[5][0]); \n\
          rC[0][1]=mad(rA[0],rB[1],rC[0][1]); \n\
          rC[1][1]=mad(rA[1],rB[1],rC[1][1]); \n\
          rC[2][1]=mad(rA[2],rB[1],rC[2][1]); \n\
          rC[3][1]=mad(rA[3],rB[1],rC[3][1]); \n\
          rC[4][1]=mad(rA[4],rB[1],rC[4][1]); \n\
          rC[5][1]=mad(rA[5],rB[1],rC[5][1]); \n\
          rC[0][2]=mad(rA[0],rB[2],rC[0][2]); \n\
          rC[1][2]=mad(rA[1],rB[2],rC[1][2]); \n\
          rC[2][2]=mad(rA[2],rB[2],rC[2][2]); \n\
          rC[3][2]=mad(rA[3],rB[2],rC[3][2]); \n\
          rC[4][2]=mad(rA[4],rB[2],rC[4][2]); \n\
          rC[5][2]=mad(rA[5],rB[2],rC[5][2]); \n\
          rC[0][3]=mad(rA[0],rB[3],rC[0][3]); \n\
          rC[1][3]=mad(rA[1],rB[3],rC[1][3]); \n\
          rC[2][3]=mad(rA[2],rB[3],rC[2][3]); \n\
          rC[3][3]=mad(rA[3],rB[3],rC[3][3]); \n\
          rC[4][3]=mad(rA[4],rB[3],rC[4][3]); \n\
          rC[5][3]=mad(rA[5],rB[3],rC[5][3]); \n\
          rC[0][4]=mad(rA[0],rB[4],rC[0][4]); \n\
          rC[1][4]=mad(rA[1],rB[4],rC[1][4]); \n\
          rC[2][4]=mad(rA[2],rB[4],rC[2][4]); \n\
          rC[3][4]=mad(rA[3],rB[4],rC[3][4]); \n\
          rC[4][4]=mad(rA[4],rB[4],rC[4][4]); \n\
          rC[5][4]=mad(rA[5],rB[4],rC[5][4]); \n\
          rC[0][5]=mad(rA[0],rB[5],rC[0][5]); \n\
          rC[1][5]=mad(rA[1],rB[5],rC[1][5]); \n\
          rC[2][5]=mad(rA[2],rB[5],rC[2][5]); \n\
          rC[3][5]=mad(rA[3],rB[5],rC[3][5]); \n\
          rC[4][5]=mad(rA[4],rB[5],rC[4][5]); \n\
          rC[5][5]=mad(rA[5],rB[5],rC[5][5]); \n\
          barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
        A += lda << 3;\n\
        B += 8;block_k+=8;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*48+ idx;\n\
    int offset_y = gidy*48+ idy;\n\
    \n\
\n\
  if(offset_x>=M ||offset_y>=N )\n\
"
"\
    return;\n\
\n\
  C+= offset_x+ldc*offset_y; \n\
 \n\
 \n\
  //for (int i=0; i<6; i++)\n\
  int i = 0;\n\
  do\n\
  {\n\
    C[0*ldc+i*8]  = alpha*rC[i][0]  ;\n\
    \n\
    if (offset_y+8<N)\n\
      C[8*ldc+i*8]  = alpha*rC[i][1] ;\n\
    \n\
    if (offset_y+16<N)\n\
      C[16*ldc+i*8] = alpha*rC[i][2] ;\n\
    \n\
    if (offset_y+24<N)\n\
      C[24*ldc+i*8] = alpha*rC[i][3];\n\
    \n\
    if (offset_y+32<N)\n\
      C[32*ldc+i*8] = alpha*rC[i][4];\n\
    \n\
    if (offset_y+40<N)\n\
      C[40*ldc+i*8] = alpha*rC[i][5];\n\
\n\
    offset_x += 8;\n\
    if(offset_x>=M)\n\
        return;\n\
\n\
\n\
  }while (++i < 6);\n\
}\n\
";


