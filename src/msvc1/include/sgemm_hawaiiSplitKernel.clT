static const char * sgemm_NT_16_SPLIT__ALPHABETA = "\
\n\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_96_16_16x16_6x6__ALPHABETA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
   // for(unsigned int block_k=0 ; block_k< K ; block_k+=16)\n\
    //{\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0+0*ldb];\n\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
//        #pragma unroll 1\n\
//        for(unsigned int k = 0 ; k < 16; k+=1){\n\
//        }\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    //}\n\
    } while (--block_k > 0);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
"
"\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[0][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[0][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[0][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[0][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[1][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[1][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[1][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[1][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[2][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[2][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[2][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[2][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[3][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[3][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[3][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[3][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[4][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[4][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[4][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[4][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[4][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[5][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[5][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[5][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[5][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[5][5] + beta*C[80*ldc];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_96_16_16x16_6x6__ALPHABETA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
"
"\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0] = B[0+0*ldb];\n\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
"
"\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
"
"\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_1_16_16x16_6x6__ALPHABETA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
"
"\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
          plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
"
"\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
  do \n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_1_16_16x16_6x6__ALPHABETA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
"
"\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
"
"\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
"
"\
    }\n\
    while (++i < 6);\n\
}\n\
";



static const char * sgemm_NT_16_SPLIT__ALPHA = "\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
"
"\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_96_16_16x16_6x6__ALPHA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
   // for(unsigned int block_k=0 ; block_k< K ; block_k+=16)\n\
    //{\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0+0*ldb];\n\
"
"\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
//        #pragma unroll 1\n\
//        for(unsigned int k = 0 ; k < 16; k+=1){\n\
//        }\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    //}\n\
    } while (--block_k > 0);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0]  ;\n\
    C[16*ldc] = alpha*rC[0][1] ;\n\
"
"\
    C[32*ldc] = alpha*rC[0][2] ;\n\
    C[48*ldc] = alpha*rC[0][3] ;\n\
    C[64*ldc] = alpha*rC[0][4] ;\n\
    C[80*ldc] = alpha*rC[0][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[1][0]  ;\n\
    C[16*ldc] = alpha*rC[1][1] ;\n\
    C[32*ldc] = alpha*rC[1][2] ;\n\
    C[48*ldc] = alpha*rC[1][3] ;\n\
    C[64*ldc] = alpha*rC[1][4] ;\n\
    C[80*ldc] = alpha*rC[1][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[2][0]  ;\n\
    C[16*ldc] = alpha*rC[2][1] ;\n\
    C[32*ldc] = alpha*rC[2][2] ;\n\
    C[48*ldc] = alpha*rC[2][3] ;\n\
    C[64*ldc] = alpha*rC[2][4] ;\n\
    C[80*ldc] = alpha*rC[2][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[3][0]  ;\n\
    C[16*ldc] = alpha*rC[3][1] ;\n\
    C[32*ldc] = alpha*rC[3][2] ;\n\
    C[48*ldc] = alpha*rC[3][3] ;\n\
    C[64*ldc] = alpha*rC[3][4] ;\n\
    C[80*ldc] = alpha*rC[3][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[4][0]  ;\n\
    C[16*ldc] = alpha*rC[4][1] ;\n\
    C[32*ldc] = alpha*rC[4][2] ;\n\
    C[48*ldc] = alpha*rC[4][3] ;\n\
    C[64*ldc] = alpha*rC[4][4] ;\n\
    C[80*ldc] = alpha*rC[4][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[5][0]  ;\n\
    C[16*ldc] = alpha*rC[5][1] ;\n\
    C[32*ldc] = alpha*rC[5][2] ;\n\
    C[48*ldc] = alpha*rC[5][3] ;\n\
    C[64*ldc] = alpha*rC[5][4] ;\n\
    C[80*ldc] = alpha*rC[5][5] ;\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_96_16_16x16_6x6__ALPHA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
"
"\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0] = B[0+0*ldb];\n\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
"
"\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      C[16*ldc] = alpha * rC[i][1];\n\
      C[32*ldc] = alpha * rC[i][2];\n\
      C[48*ldc] = alpha * rC[i][3];\n\
      C[64*ldc] = alpha * rC[i][4];\n\
      C[80*ldc] = alpha * rC[i][5];\n\
      C+=16;\n\
"
"\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_1_16_16x16_6x6__ALPHA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
"
"\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
"
"\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_1_16_16x16_6x6__ALPHA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
"
"\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
"
"\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";














/*********************************************************************************************************************/

static const char * sgemm_NT_1_SPLIT__ALPHABETA = "\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_96_1_16x16_6x6__ALPHABETA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
       // barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0+0*ldb];\n\
"
"\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
"
"\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16 ;\n\
    } while (block_k < K);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[0][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[0][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[0][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[0][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[1][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[1][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[1][4] + beta*C[64*ldc];\n\
"
"\
    C[80*ldc] = alpha*rC[1][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[2][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[2][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[2][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[2][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[3][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[3][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[3][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[3][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[4][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[4][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[4][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[4][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[4][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[5][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[5][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[5][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[5][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[5][5] + beta*C[80*ldc];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_96_1_16x16_6x6__ALPHABETA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
"
"\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//= K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0] = B[0+0*ldb];\n\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
"
"\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
"
"\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_1_1_16x16_6x6__ALPHABETA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
"
"\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
"
"\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
"
"\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
"
"\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_1_1_16x16_6x6__ALPHABETA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
"
"\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
"
"\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
"
"\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";



static const char * sgemm_NT_1_SPLIT__ALPHA = "\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
"
"\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_96_1_16x16_6x6__ALPHA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k =0;// K >> 4;\n\
    do \n\
    {\n\
   // for(unsigned int block_k=0 ; block_k< K ; block_k+=16)\n\
    //{\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
       // barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0+0*ldb];\n\
"
"\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
"
"\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0]  ;\n\
    C[16*ldc] = alpha*rC[0][1] ;\n\
    C[32*ldc] = alpha*rC[0][2] ;\n\
    C[48*ldc] = alpha*rC[0][3] ;\n\
    C[64*ldc] = alpha*rC[0][4] ;\n\
    C[80*ldc] = alpha*rC[0][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[1][0]  ;\n\
    C[16*ldc] = alpha*rC[1][1] ;\n\
    C[32*ldc] = alpha*rC[1][2] ;\n\
    C[48*ldc] = alpha*rC[1][3] ;\n\
    C[64*ldc] = alpha*rC[1][4] ;\n\
    C[80*ldc] = alpha*rC[1][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[2][0]  ;\n\
"
"\
    C[16*ldc] = alpha*rC[2][1] ;\n\
    C[32*ldc] = alpha*rC[2][2] ;\n\
    C[48*ldc] = alpha*rC[2][3] ;\n\
    C[64*ldc] = alpha*rC[2][4] ;\n\
    C[80*ldc] = alpha*rC[2][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[3][0]  ;\n\
    C[16*ldc] = alpha*rC[3][1] ;\n\
    C[32*ldc] = alpha*rC[3][2] ;\n\
    C[48*ldc] = alpha*rC[3][3] ;\n\
    C[64*ldc] = alpha*rC[3][4] ;\n\
    C[80*ldc] = alpha*rC[3][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[4][0]  ;\n\
    C[16*ldc] = alpha*rC[4][1] ;\n\
    C[32*ldc] = alpha*rC[4][2] ;\n\
    C[48*ldc] = alpha*rC[4][3] ;\n\
    C[64*ldc] = alpha*rC[4][4] ;\n\
    C[80*ldc] = alpha*rC[4][5] ;\n\
    C+=16;                       \n\
    C[0*ldc] = alpha*rC[5][0]  ;\n\
    C[16*ldc] = alpha*rC[5][1] ;\n\
    C[32*ldc] = alpha*rC[5][2] ;\n\
    C[48*ldc] = alpha*rC[5][3] ;\n\
    C[64*ldc] = alpha*rC[5][4] ;\n\
    C[80*ldc] = alpha*rC[5][5] ;\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_1_96_1_16x16_6x6__ALPHA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
"
"\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0] = B[0+0*ldb];\n\
        plB[16] = B[16+0*ldb];\n\
        plB[32] = B[32+0*ldb];\n\
        plB[48] = B[48+0*ldb];\n\
        plB[64] = B[64+0*ldb];\n\
        plB[80] = B[80+0*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
"
"\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
\n\
\n\
        }\n\
\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      C[16*ldc] = alpha * rC[i][1];\n\
      C[32*ldc] = alpha * rC[i][2];\n\
      C[48*ldc] = alpha * rC[i][3];\n\
      C[64*ldc] = alpha * rC[i][4];\n\
      C[80*ldc] = alpha * rC[i][5];\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NT_96_1_1_16x16_6x6__ALPHA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
"
"\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
       \n\
        plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
"
"\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
"
"\
__kernel void sgemm_NT_1_1_1_16x16_6x6__ALPHA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;// K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idy*97+idx;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80];\n\
"
"\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
"
"\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
        A += lda<<4;\n\
        B += ldb<<4;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
"
"\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static const char * sgemm_NN_16_SPLIT__ALPHABETA = "\
\n\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_96_16_16x16_6x6__ALPHABETA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0];\n\
"
"\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
          plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
          M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    //}\n\
    } while (--block_k > 0);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[0][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[0][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[0][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[0][5] + beta*C[80*ldc];\n\
"
"\
    C+=16;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[1][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[1][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[1][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[1][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[2][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[2][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[2][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[2][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[3][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[3][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[3][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[3][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[4][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[4][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[4][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[4][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[4][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[5][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[5][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[5][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[5][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[5][5] + beta*C[80*ldc];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_96_16_16x16_6x6__ALPHABETA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
"
"\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
   int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
          plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
"
"\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
"
"\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_1_16_16x16_6x6__ALPHABETA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
"
"\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
"
"\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_1_16_16x16_6x6__ALPHABETA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
"
"\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
"
"\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";





static const char * sgemm_NN_16_SPLIT__ALPHA = "\
\n\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_96_16_16x16_6x6__ALPHA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
   // for(unsigned int block_k=0 ; block_k< K ; block_k+=16)\n\
    //{\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
//        #pragma unroll 1\n\
//        for(unsigned int k = 0 ; k < 16; k+=1){\n\
//        }\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    //}\n\
    } while (--block_k > 0);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
"
"\
    C[16*ldc] = alpha*rC[0][1];\n\
    C[32*ldc] = alpha*rC[0][2];\n\
    C[48*ldc] = alpha*rC[0][3];\n\
    C[64*ldc] = alpha*rC[0][4];\n\
    C[80*ldc] = alpha*rC[0][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[16*ldc] = alpha*rC[1][1];\n\
    C[32*ldc] = alpha*rC[1][2];\n\
    C[48*ldc] = alpha*rC[1][3];\n\
    C[64*ldc] = alpha*rC[1][4];\n\
    C[80*ldc] = alpha*rC[1][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[16*ldc] = alpha*rC[2][1];\n\
    C[32*ldc] = alpha*rC[2][2];\n\
    C[48*ldc] = alpha*rC[2][3];\n\
    C[64*ldc] = alpha*rC[2][4];\n\
    C[80*ldc] = alpha*rC[2][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[16*ldc] = alpha*rC[3][1];\n\
    C[32*ldc] = alpha*rC[3][2];\n\
    C[48*ldc] = alpha*rC[3][3];\n\
    C[64*ldc] = alpha*rC[3][4];\n\
    C[80*ldc] = alpha*rC[3][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[4][0] ;\n\
    C[16*ldc] = alpha*rC[4][1];\n\
    C[32*ldc] = alpha*rC[4][2];\n\
    C[48*ldc] = alpha*rC[4][3];\n\
    C[64*ldc] = alpha*rC[4][4];\n\
    C[80*ldc] = alpha*rC[4][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[5][0] ;\n\
    C[16*ldc] = alpha*rC[5][1];\n\
    C[32*ldc] = alpha*rC[5][2];\n\
    C[48*ldc] = alpha*rC[5][3];\n\
    C[64*ldc] = alpha*rC[5][4];\n\
    C[80*ldc] = alpha*rC[5][5];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_96_16_16x16_6x6__ALPHA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
"
"\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
"
"\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      C[16*ldc] = alpha * rC[i][1];\n\
      C[32*ldc] = alpha * rC[i][2];\n\
      C[48*ldc] = alpha * rC[i][3];\n\
      C[64*ldc] = alpha * rC[i][4];\n\
      C[80*ldc] = alpha * rC[i][5];\n\
"
"\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_1_16_16x16_6x6__ALPHA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
"
"\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
"
"\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0] ;\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_1_16_16x16_6x6__ALPHA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
"
"\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
"
"\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
        M6x6\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
    } while (--block_k > 0);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0] ;\n\
      if(offset_y+16<N)                   \n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)                 \n\
        C[32*ldc] = alpha * rC[i][2];\n\
      if(offset_y+48<N)                 \n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)                 \n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)            \n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
"
"\
";


























static const char * sgemm_NN_1_SPLIT__ALPHABETA = "\
\n\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_96_1_16x16_6x6__ALPHABETA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    int block_k = 0;//K >> 4\n\
    do \n\
    {\n\
   // for(unsigned int block_k=0 ; block_k< K ; block_k+=16)\n\
    //{\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
"
"\
       // barrier(CLK_LOCAL_MEM_FENCE);\n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
        plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
"
"\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[0][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[0][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[0][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[0][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[1][2] + beta*C[32*ldc];\n\
"
"\
    C[48*ldc] = alpha*rC[1][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[1][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[1][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[2][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[2][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[2][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[2][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[3][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[3][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[3][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[3][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[4][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[4][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[4][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[4][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[4][5] + beta*C[80*ldc];\n\
    C+=16;\n\
    C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[5][1] + beta*C[16*ldc];\n\
    C[32*ldc] = alpha*rC[5][2] + beta*C[32*ldc];\n\
    C[48*ldc] = alpha*rC[5][3] + beta*C[48*ldc];\n\
    C[64*ldc] = alpha*rC[5][4] + beta*C[64*ldc];\n\
    C[80*ldc] = alpha*rC[5][5] + beta*C[80*ldc];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_96_1_16x16_6x6__ALPHABETA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
"
"\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    int block_k = 0;//K >> 4\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
"
"\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
"
"\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_1_1_16x16_6x6__ALPHABETA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
"
"\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    int block_k = 0;//K >> 4\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = A[0];\n\
"
"\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
"
"\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
"
"\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_1_1_16x16_6x6__ALPHABETA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    int block_k = 0;//K >> 4\n\
    do \n\
"
"\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
\n\
      // plB[0]  = (CurrentOffSetB>=N || idx>=M)?0.0:B[0];\n\
      // plB[16] = (CurrentOffSetB+16>=N || idx>=M)?0.0:B[16*ldb];\n\
      // plB[32] = (CurrentOffSetB+32>=N || idx>=M)?0.0:B[32*ldb];\n\
      // plB[48] = (CurrentOffSetB+48>=N || idx>=M)?0.0:B[48*ldb];\n\
      // plB[64] = (CurrentOffSetB+64>=N || idx>=M)?0.0:B[64*ldb];\n\
      // plB[80] = (CurrentOffSetB+80>=N || idx>=M)?0.0:B[80*ldb];\n\
\n\
       \n\
        plA[0]  = (CurrentOffSetA>=M )?0.0:A[0];\n\
        plA[16] = (CurrentOffSetA+16>=M )?0.0:A[16];\n\
        plA[32] = (CurrentOffSetA+32>=M )?0.0:A[32];\n\
        plA[48] = (CurrentOffSetA+48>=M )?0.0:A[48];\n\
        plA[64] = (CurrentOffSetA+64>=M )?0.0:A[64];\n\
        plA[80] = (CurrentOffSetA+80>=M )?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
"
"\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    }  while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
"
"\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
      if(offset_y+16<N)\n\
        C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
      if(offset_y+32<N)\n\
        C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
      if(offset_y+48<N)\n\
        C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
      if(offset_y+64<N)\n\
        C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
      if(offset_y+80<N)\n\
        C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";





static const char * sgemm_NN_1_SPLIT__ALPHA = "\
\n\
#define  M6x6 \\n\
            rA[0][0] = lA[offA + 0];                  \\n\
            rA[0][1] = lA[offA + 16];                  \\n\
            rA[0][2] = lA[offA + 32];                  \\n\
            rA[0][3] = lA[offA + 48];                  \\n\
            rA[0][4] = lA[offA + 64];                  \\n\
            rA[0][5] = lA[offA + 80];                  \\n\
            rB[0][0] = lB[offB + 0];                  \\n\
            rB[0][1] = lB[offB + 16];                  \\n\
            rB[0][2] = lB[offB + 32];                  \\n\
            rB[0][3] = lB[offB + 48];                  \\n\
            rB[0][4] = lB[offB + 64];                  \\n\
            rB[0][5] = lB[offB + 80];                  \\n\
            offA += 97;                                  \\n\
            offB += 97;                                  \\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
            mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_96_1_16x16_6x6__ALPHA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
\n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
\n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
      \n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
"
"\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
          plA[0] = A[0+0*lda];\n\
        plA[16] = A[16+0*lda];\n\
        plA[32] = A[32+0*lda];\n\
        plA[48] = A[48+0*lda];\n\
        plA[64] = A[64+0*lda];\n\
        plA[80] = A[80+0*lda];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
          {\n\
\n\
              rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
"
"\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
    C+= gidx*96+idx;\n\
    C+= gidy*96*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[16*ldc] = alpha*rC[0][1];\n\
    C[32*ldc] = alpha*rC[0][2];\n\
    C[48*ldc] = alpha*rC[0][3];\n\
    C[64*ldc] = alpha*rC[0][4];\n\
    C[80*ldc] = alpha*rC[0][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[16*ldc] = alpha*rC[1][1];\n\
    C[32*ldc] = alpha*rC[1][2];\n\
    C[48*ldc] = alpha*rC[1][3];\n\
    C[64*ldc] = alpha*rC[1][4];\n\
    C[80*ldc] = alpha*rC[1][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
"
"\
    C[16*ldc] = alpha*rC[2][1];\n\
    C[32*ldc] = alpha*rC[2][2];\n\
    C[48*ldc] = alpha*rC[2][3];\n\
    C[64*ldc] = alpha*rC[2][4];\n\
    C[80*ldc] = alpha*rC[2][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[16*ldc] = alpha*rC[3][1];\n\
    C[32*ldc] = alpha*rC[3][2];\n\
    C[48*ldc] = alpha*rC[3][3];\n\
    C[64*ldc] = alpha*rC[3][4];\n\
    C[80*ldc] = alpha*rC[3][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[4][0] ;\n\
    C[16*ldc] = alpha*rC[4][1];\n\
    C[32*ldc] = alpha*rC[4][2];\n\
    C[48*ldc] = alpha*rC[4][3];\n\
    C[64*ldc] = alpha*rC[4][4];\n\
    C[80*ldc] = alpha*rC[4][5];\n\
    C+=16;                      ;\n\
    C[0*ldc] = alpha*rC[5][0] ;\n\
    C[16*ldc] = alpha*rC[5][1];\n\
    C[32*ldc] = alpha*rC[5][2];\n\
    C[48*ldc] = alpha*rC[5][3];\n\
    C[64*ldc] = alpha*rC[5][4];\n\
    C[80*ldc] = alpha*rC[5][5];\n\
   \n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_96_1_16x16_6x6__ALPHA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
"
"\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
\n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0] = B[0];\n\
        plB[16] = B[16*ldb];\n\
        plB[32] = B[32*ldb];\n\
        plB[48] = B[48*ldb];\n\
        plB[64] = B[64*ldb];\n\
        plB[80] = B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
"
"\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
\n\
\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0];\n\
      C[16*ldc] = alpha * rC[i][1];\n\
      C[32*ldc] = alpha * rC[i][2];\n\
      C[48*ldc] = alpha * rC[i][3];\n\
      C[64*ldc] = alpha * rC[i][4];\n\
      C[80*ldc] = alpha * rC[i][5];\n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
    }\n\
    while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_96_1_1_16x16_6x6__ALPHA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
"
"\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
          plA[0]  = A[0];\n\
        plA[16] = A[16];\n\
        plA[32] = A[32];\n\
        plA[48] = A[48];\n\
        plA[64] = A[64];\n\
        plA[80] = A[80];\n\
\n\
"
"\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
          {\n\
\n\
              rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
"
"\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
                  barrier(CLK_LOCAL_MEM_FENCE);\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_y>=N )\n\
      return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
    \n\
  int i = 0;\n\
  do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0] ;\n\
      if(offset_y+16<N)\n\
      C[16*ldc] = alpha * rC[i][1];\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = alpha * rC[i][2];\n\
    if(offset_y+48<N)\n\
      C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)\n\
      C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)\n\
      C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
        \n\
    }\n\
  while (++i < 6);\n\
}\n\
"
"\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
__kernel void sgemm_NN_1_1_1_16x16_6x6__ALPHA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
    float rC[6][6]  = {(float)0};\n\
    float rA[1][6];\n\
    float rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local float lA[1552];\n\
    __local float lB[1552];\n\
    \n\
    uint gidx = M/96;//get_group_id(0);\n\
    uint gidy = N/96;//get_group_id(1);\n\
    uint idx = get_local_id(0);\n\
    uint idy = get_local_id(1);\n\
    \n\
    int CurrentOffSetA = gidx*96+ idx;\n\
    int CurrentOffSetB = gidy*96+ idy;\n\
    \n\
    A +=  gidx*96+ idx + idy*lda;\n\
    B +=  gidy*96*ldb+ idx + idy*ldb;\n\
    \n\
   \n\
    uint block_k = 0;//K >> 4;\n\
    do \n\
    {\n\
        __local float* plA = lA + idy*97+idx;\n\
        __local float* plB = lB + idx*97+idy;\n\
\n\
        plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
        plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
"
"\
        plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
        plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
       \n\
        plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
        plA[32] = CurrentOffSetA+32>=M?0.0:A[32];\n\
        plA[48] = CurrentOffSetA+48>=M?0.0:A[48];\n\
        plA[64] = CurrentOffSetA+64>=M?0.0:A[64];\n\
        plA[80] = CurrentOffSetA+80>=M?0.0:A[80];\n\
\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        uint offA = idx;\n\
        uint offB = idy;\n\
\n\
\n\
        #pragma unroll 1\n\
        for(unsigned int k = 0 ; k < min(16u, K-block_k ); k+=1)\n\
        {\n\
\n\
            rA[0][0] = lA[offA + 0];                  \n\
            rA[0][1] = lA[offA + 16];                  \n\
            rA[0][2] = lA[offA + 32];                  \n\
            rA[0][3] = lA[offA + 48];                  \n\
            rA[0][4] = lA[offA + 64];                  \n\
            rA[0][5] = lA[offA + 80];                  \n\
            rB[0][0] = lB[offB + 0];                  \n\
            rB[0][1] = lB[offB + 16];                  \n\
            rB[0][2] = lB[offB + 32];                  \n\
            rB[0][3] = lB[offB + 48];                  \n\
            rB[0][4] = lB[offB + 64];                  \n\
            rB[0][5] = lB[offB + 80];                  \n\
            offA += 97;                                  \n\
            offB += 97;                                  \n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \n\
"
"\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \n\
            barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
        }\n\
\n\
\n\
\n\
        A += lda<<4;\n\
        B += 16;\n\
        block_k+=16;\n\
    } while (block_k < K);\n\
\n\
\n\
    int offset_x = gidx*96+idx;\n\
    int offset_y = gidy*96+ idy;\n\
\n\
    if(offset_x>=M || offset_y>=N )\n\
      return;\n\
\n\
    C+=offset_x+offset_y*ldc;\n\
    \n\
    int i = 0;\n\
    do \n\
    //for (int i=0; i<6; i++)\n\
    {\n\
      C[0     ] = alpha * rC[i][0] ;\n\
      if(offset_y+16<N)                   \n\
        C[16*ldc] = alpha * rC[i][1];\n\
      if(offset_y+32<N)                 \n\
        C[32*ldc] = alpha * rC[i][2];\n\
"
"\
      if(offset_y+48<N)                 \n\
        C[48*ldc] = alpha * rC[i][3];\n\
      if(offset_y+64<N)                 \n\
        C[64*ldc] = alpha * rC[i][4];\n\
      if(offset_y+80<N)            \n\
        C[80*ldc] = alpha * rC[i][5];\n\
      \n\
      C+=16;\n\
      offset_x+=16;\n\
      if(offset_x>=M )\n\
        return;\n\
\n\
        \n\
    }\n\
    while (++i < 6);\n\
}\n\
";






/*************************************************************************************************/
static const char * sgemm_TN_16_SPLIT__ALPHABETA = "\
\n\
#define  M6x6 \\n\
  rA[0][0] = lA[offA + 0];                  \\n\
  rA[0][1] = lA[offA + 16];                  \\n\
  rA[0][2] = lA[offA + 32];                  \\n\
  rA[0][3] = lA[offA + 48];                  \\n\
  rA[0][4] = lA[offA + 64];                  \\n\
  rA[0][5] = lA[offA + 80];                  \\n\
  rB[0][0] = lB[offB + 0];                  \\n\
  rB[0][1] = lB[offB + 16];                  \\n\
  rB[0][2] = lB[offB + 32];                  \\n\
  rB[0][3] = lB[offB + 48];                  \\n\
  rB[0][4] = lB[offB + 64];                  \\n\
  rB[0][5] = lB[offB + 80];                  \\n\
  offA += 97;                                  \\n\
  offB += 97;                                  \\n\
  rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
  rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
  rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
  rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
  rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
  rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
  rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
  rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
  rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
  rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
  rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
  rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
  rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
  rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
  rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
  rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
  rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
  rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
  rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
  rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
  rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
  rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
  rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
  rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
  rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
  rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
  rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
  rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
  rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
  rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
  rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
  rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
  rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
  rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
  rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
  rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
  mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_96_96_16_16x16_6x6__ALPHABETA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = get_group_id(0);\n\
  uint gidy = get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
"
"\
    plB[0] = B[0];\n\
    plB[16] = B[16*ldb];\n\
    plB[32] = B[32*ldb];\n\
    plB[48] = B[48*ldb];\n\
    plB[64] = B[64*ldb];\n\
    plB[80] = B[80*ldb];\n\
\n\
    plA[0] = A[0];\n\
    plA[16] = A[16*lda];\n\
    plA[32] = A[32*lda];\n\
    plA[48] = A[48*lda];\n\
    plA[64] = A[64*lda];\n\
    plA[80] = A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
  C+= gidx*96+idx;\n\
  C+= gidy*96*ldc;\n\
  C+= idy*ldc;\n\
\n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[0][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[0][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[0][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[0][5] + beta*C[80*ldc];\n\
"
"\
  C+=16;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[1][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[1][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[1][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[1][5] + beta*C[80*ldc];\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[2][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[2][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[2][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[2][5] + beta*C[80*ldc];\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[3][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[3][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[3][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[3][5] + beta*C[80*ldc];\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[4][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[4][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[4][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[4][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[4][5] + beta*C[80*ldc];\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
  C[16*ldc] = alpha*rC[5][1] + beta*C[16*ldc];\n\
  C[32*ldc] = alpha*rC[5][2] + beta*C[32*ldc];\n\
  C[48*ldc] = alpha*rC[5][3] + beta*C[48*ldc];\n\
  C[64*ldc] = alpha*rC[5][4] + beta*C[64*ldc];\n\
  C[80*ldc] = alpha*rC[5][5] + beta*C[80*ldc];\n\
\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_1_96_16_16x16_6x6__ALPHABETA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
"
"\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = M/96;//get_group_id(0);\n\
  uint gidy = get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
\n\
  int CurrentOffSetA = gidx*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0] = B[0];\n\
    plB[16] = B[16*ldb];\n\
    plB[32] = B[32*ldb];\n\
    plB[48] = B[48*ldb];\n\
    plB[64] = B[64*ldb];\n\
    plB[80] = B[80*ldb];\n\
\n\
    plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
    plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
    plA[32] = CurrentOffSetA+32>=M?0.0:A[32*lda];\n\
    plA[48] = CurrentOffSetA+48>=M?0.0:A[48*lda];\n\
    plA[64] = CurrentOffSetA+64>=M?0.0:A[64*lda];\n\
    plA[80] = CurrentOffSetA+80>=M?0.0:A[80*lda];\n\
\n\
"
"\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
    C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
    C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
    C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
    C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
    C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
      return;\n\
"
"\
  }\n\
  while (++i < 6);\n\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_96_1_16_16x16_6x6__ALPHABETA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = get_group_id(0);\n\
  uint gidy = N/96;//get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  int CurrentOffSetB = gidy*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
"
"\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
    plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
    plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
    plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
    plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
    plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
\n\
    plA[0]  = A[0];\n\
    plA[16] = A[16*lda];\n\
    plA[32] = A[32*lda];\n\
    plA[48] = A[48*lda];\n\
    plA[64] = A[64*lda];\n\
    plA[80] = A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_y>=N )\n\
"
"\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
    if(offset_y+48<N)\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
    if(offset_y+64<N)\n\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
    if(offset_y+80<N)\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
\n\
    C+=16;\n\
\n\
  }\n\
  while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_1_1_16_16x16_6x6__ALPHABETA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  float const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
"
"\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = M/96;//get_group_id(0);\n\
  uint gidy = N/96;//get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  int CurrentOffSetA = gidx*96+ idy;\n\
  int CurrentOffSetB = gidy*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
    plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
    plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
    plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
    plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
    plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
\n\
    plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
    plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
    plA[32] = CurrentOffSetA+32>=M?0.0:A[32*lda];\n\
    plA[48] = CurrentOffSetA+48>=M?0.0:A[48*lda];\n\
    plA[64] = CurrentOffSetA+64>=M?0.0:A[64*lda];\n\
    plA[80] = CurrentOffSetA+80>=M?0.0:A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
"
"\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], beta*C[0]);\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad(alpha, rC[i][1], beta*C[16*ldc]);\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad(alpha, rC[i][2], beta*C[32*ldc]);\n\
    if(offset_y+48<N)\n\
      C[48*ldc] = mad(alpha, rC[i][3], beta*C[48*ldc]);\n\
    if(offset_y+64<N)\n\
      C[64*ldc] = mad(alpha, rC[i][4], beta*C[64*ldc]);\n\
    if(offset_y+80<N)\n\
      C[80*ldc] = mad(alpha, rC[i][5], beta*C[80*ldc]);\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
\n\
  }\n\
  while (++i < 6);\n\
}\n\
";



static const char * sgemm_TN_16_SPLIT__ALPHA = "\
\n\
#define  M6x6 \\n\
  rA[0][0] = lA[offA + 0];                  \\n\
  rA[0][1] = lA[offA + 16];                  \\n\
  rA[0][2] = lA[offA + 32];                  \\n\
  rA[0][3] = lA[offA + 48];                  \\n\
  rA[0][4] = lA[offA + 64];                  \\n\
  rA[0][5] = lA[offA + 80];                  \\n\
  rB[0][0] = lB[offB + 0];                  \\n\
  rB[0][1] = lB[offB + 16];                  \\n\
  rB[0][2] = lB[offB + 32];                  \\n\
  rB[0][3] = lB[offB + 48];                  \\n\
  rB[0][4] = lB[offB + 64];                  \\n\
  rB[0][5] = lB[offB + 80];                  \\n\
  offA += 97;                                  \\n\
  offB += 97;                                  \\n\
  rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]); \\n\
  rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]); \\n\
  rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]); \\n\
  rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]); \\n\
  rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]); \\n\
  rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]); \\n\
  rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]); \\n\
  rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]); \\n\
  rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]); \\n\
  rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]); \\n\
  rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]); \\n\
  rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]); \\n\
  rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]); \\n\
  rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]); \\n\
  rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]); \\n\
  rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]); \\n\
  rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]); \\n\
  rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]); \\n\
  rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]); \\n\
  rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]); \\n\
  rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]); \\n\
  rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]); \\n\
  rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]); \\n\
  rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]); \\n\
  rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]); \\n\
  rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]); \\n\
  rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]); \\n\
  rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]); \\n\
  rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]); \\n\
  rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]); \\n\
  rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]); \\n\
  rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]); \\n\
  rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]); \\n\
"
"\
  rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]); \\n\
  rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]); \\n\
  rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]); \\n\
  mem_fence(CLK_LOCAL_MEM_FENCE);\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_96_96_16_16x16_6x6__ALPHA_SPLIT_MAIN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = get_group_id(0);\n\
  uint gidy = get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0] = B[0];\n\
"
"\
    plB[16] = B[16*ldb];\n\
    plB[32] = B[32*ldb];\n\
    plB[48] = B[48*ldb];\n\
    plB[64] = B[64*ldb];\n\
    plB[80] = B[80*ldb];\n\
\n\
    plA[0] = A[0];\n\
    plA[16] = A[16*lda];\n\
    plA[32] = A[32*lda];\n\
    plA[48] = A[48*lda];\n\
    plA[64] = A[64*lda];\n\
    plA[80] = A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
  C+= gidx*96+idx;\n\
  C+= gidy*96*ldc;\n\
  C+= idy*ldc;\n\
\n\
  C[0*ldc] = alpha*rC[0][0]  ;\n\
  C[16*ldc] = alpha*rC[0][1] ;\n\
  C[32*ldc] = alpha*rC[0][2] ;\n\
  C[48*ldc] = alpha*rC[0][3] ;\n\
  C[64*ldc] = alpha*rC[0][4] ;\n\
  C[80*ldc] = alpha*rC[0][5] ;\n\
  C+=16;\n\
"
"\
  C[0*ldc] = alpha*rC[1][0]  ;\n\
  C[16*ldc] = alpha*rC[1][1] ;\n\
  C[32*ldc] = alpha*rC[1][2] ;\n\
  C[48*ldc] = alpha*rC[1][3] ;\n\
  C[64*ldc] = alpha*rC[1][4] ;\n\
  C[80*ldc] = alpha*rC[1][5] ;\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[2][0]  ;\n\
  C[16*ldc] = alpha*rC[2][1] ;\n\
  C[32*ldc] = alpha*rC[2][2] ;\n\
  C[48*ldc] = alpha*rC[2][3] ;\n\
  C[64*ldc] = alpha*rC[2][4] ;\n\
  C[80*ldc] = alpha*rC[2][5] ;\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[3][0]  ;\n\
  C[16*ldc] = alpha*rC[3][1] ;\n\
  C[32*ldc] = alpha*rC[3][2] ;\n\
  C[48*ldc] = alpha*rC[3][3] ;\n\
  C[64*ldc] = alpha*rC[3][4] ;\n\
  C[80*ldc] = alpha*rC[3][5] ;\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[4][0]  ;\n\
  C[16*ldc] = alpha*rC[4][1] ;\n\
  C[32*ldc] = alpha*rC[4][2] ;\n\
  C[48*ldc] = alpha*rC[4][3] ;\n\
  C[64*ldc] = alpha*rC[4][4] ;\n\
  C[80*ldc] = alpha*rC[4][5] ;\n\
  C+=16;\n\
  C[0*ldc] = alpha*rC[5][0]  ;\n\
  C[16*ldc] = alpha*rC[5][1] ;\n\
  C[32*ldc] = alpha*rC[5][2] ;\n\
  C[48*ldc] = alpha*rC[5][3] ;\n\
  C[64*ldc] = alpha*rC[5][4] ;\n\
  C[80*ldc] = alpha*rC[5][5] ;\n\
\n\
}\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_1_96_16_16x16_6x6__ALPHA_SPLIT_ROW( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
"
"\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = M/96;//get_group_id(0);\n\
  uint gidy = get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
\n\
  int CurrentOffSetA = gidx*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0] = B[0];\n\
    plB[16] = B[16*ldb];\n\
    plB[32] = B[32*ldb];\n\
    plB[48] = B[48*ldb];\n\
    plB[64] = B[64*ldb];\n\
    plB[80] = B[80*ldb];\n\
\n\
    plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
    plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
    plA[32] = CurrentOffSetA+32>=M?0.0:A[32*lda];\n\
    plA[48] = CurrentOffSetA+48>=M?0.0:A[48*lda];\n\
    plA[64] = CurrentOffSetA+64>=M?0.0:A[64*lda];\n\
    plA[80] = CurrentOffSetA+80>=M?0.0:A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_x>=M )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], 0);\n\
    C[16*ldc] = mad(alpha, rC[i][1], 0);\n\
    C[32*ldc] = mad(alpha, rC[i][2], 0);\n\
    C[48*ldc] = mad(alpha, rC[i][3], 0);\n\
    C[64*ldc] = mad(alpha, rC[i][4], 0);\n\
    C[80*ldc] = mad(alpha, rC[i][5], 0);\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
      return;\n\
  }\n\
  while (++i < 6);\n\
"
"\
}\n\
\n\
\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_96_1_16_16x16_6x6__ALPHA_SPLIT_COLUMN( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
  uint gidx = get_group_id(0);\n\
  uint gidy = N/96;//get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  int CurrentOffSetB = gidy*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
\n\
    plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
    plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
    plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
    plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
    plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
    plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
\n\
    plA[0]  = A[0];\n\
    plA[16] = A[16*lda];\n\
    plA[32] = A[32*lda];\n\
    plA[48] = A[48*lda];\n\
    plA[64] = A[64*lda];\n\
    plA[80] = A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
"
"\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], 0);\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad(alpha, rC[i][1], 0);\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad(alpha, rC[i][2], 0);\n\
    if(offset_y+48<N)\n\
      C[48*ldc] = mad(alpha, rC[i][3], 0);\n\
    if(offset_y+64<N)\n\
      C[64*ldc] = mad(alpha, rC[i][4], 0);\n\
    if(offset_y+80<N)\n\
      C[80*ldc] = mad(alpha, rC[i][5], 0);\n\
\n\
    C+=16;\n\
\n\
  }\n\
  while (++i < 6);\n\
}\n\
\n\
__attribute__((reqd_work_group_size(16,16,1)))\n\
  __kernel void sgemm_TN_1_1_16_16x16_6x6__ALPHA_SPLIT_SINGLE( __global float const * restrict A,\n\
  __global float const * restrict B,\n\
  __global float * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  float const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  float rC[6][6]  = {(float)0};\n\
  float rA[1][6];\n\
  float rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local float lA[1552];\n\
  __local float lB[1552];\n\
\n\
"
"\
  uint gidx = M/96;//get_group_id(0);\n\
  uint gidy = N/96;//get_group_id(1);\n\
  uint idx = get_local_id(0);\n\
  uint idy = get_local_id(1);\n\
\n\
  int CurrentOffSetA = gidx*96+ idy;\n\
  int CurrentOffSetB = gidy*96+ idy;\n\
\n\
  A +=  (gidx*96+idy)*lda + idx;\n\
  B +=  (gidy*96+idy)*ldb + idx;\n\
\n\
\n\
  uint block_k = K >> 4;\n\
  do \n\
  {\n\
    __local float* plA = lA + idx*97+idy;\n\
    __local float* plB = lB + idx*97+idy;\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    plB[0]  = CurrentOffSetB>=N?0.0:B[0];\n\
    plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
    plB[32] = CurrentOffSetB+32>=N?0.0:B[32*ldb];\n\
    plB[48] = CurrentOffSetB+48>=N?0.0:B[48*ldb];\n\
    plB[64] = CurrentOffSetB+64>=N?0.0:B[64*ldb];\n\
    plB[80] = CurrentOffSetB+80>=N?0.0:B[80*ldb];\n\
\n\
    plA[0]  = CurrentOffSetA>=M?0.0:A[0];\n\
    plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
    plA[32] = CurrentOffSetA+32>=M?0.0:A[32*lda];\n\
    plA[48] = CurrentOffSetA+48>=M?0.0:A[48*lda];\n\
    plA[64] = CurrentOffSetA+64>=M?0.0:A[64*lda];\n\
    plA[80] = CurrentOffSetA+80>=M?0.0:A[80*lda];\n\
\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    uint offA = idx;\n\
    uint offB = idy;\n\
\n\
\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
"
"\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
    M6x6\n\
\n\
    A += 16;\n\
    B += 16;\n\
  } while (--block_k > 0);\n\
\n\
\n\
  int offset_x = gidx*96+idx;\n\
  int offset_y = gidy*96+ idy;\n\
\n\
  if(offset_x>=M || offset_y>=N )\n\
    return;\n\
\n\
  C+=offset_x+offset_y*ldc;\n\
\n\
  int i = 0;\n\
  do \n\
  //for (int i=0; i<6; i++)\n\
  {\n\
    C[0     ] = mad(alpha, rC[i][0], 0);\n\
    if(offset_y+16<N)\n\
      C[16*ldc] = mad(alpha, rC[i][1], 0);\n\
    if(offset_y+32<N)\n\
      C[32*ldc] = mad(alpha, rC[i][2], 0);\n\
    if(offset_y+48<N)\n\
      C[48*ldc] = mad(alpha, rC[i][3], 0);\n\
    if(offset_y+64<N)\n\
      C[64*ldc] = mad(alpha, rC[i][4], 0);\n\
    if(offset_y+80<N)\n\
      C[80*ldc] = mad(alpha, rC[i][5], 0);\n\
\n\
    C+=16;\n\
    offset_x+=16;\n\
    if(offset_x>=M )\n\
      return;\n\
\n\
\n\
  }\n\
  while (++i < 6);\n\
}\n\
";




