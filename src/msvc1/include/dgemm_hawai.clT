
// DGEMM kernels for Hawai & Tahiti 
//
// All kernels are ColumnMajor. The case RowMajor is handled by an earlier transformation 
// into an equivalent ColumnMajor (using the property that (A*B)' is equal to B'A' that the 
// conversion from Row to Column major is basically a transpose) 
//
// The naming scheme for the kernels is dgemm_<ta><tb>_<divn>_<divm>_<divk>_<bs0>x<bs1>_<nv0>x<nv1> where 
//    - <ta> is N or T representing the transpose operation on A
//    - <tb> is N or T representing the transpose operation on B
//    - <divn> is a required divisor of N (1 for any value)
//    - <divm> is a required divisor of M (1 for any value)
//    - <divk> is a required divisor of K (1 for any value)
//    - <bs0>x<bs1> is the block size
//    - <nv0>x<nv1> is the number of points computed per work-item
//
// For instance a kernel named 'dgemm_NT_16_32_1_8x8_2x4' 
//    - would implement C = C + A * B' 
//    - for N multiple of 16
//    - for M multiple of 32 
//    - for any value of K
//    - using work-groups of size (8,8)
//    - with each thread computing 2x4 points of C 
//
//
// The kernel prototype shall be compatible with
//
//    __kernel void dgemm( __global double const * restrict A, 
//                         __global double const * restrict B, 
//                         __global double * C,
//                         uint   M, 
//                         uint   N, 
//                         uint   K,
//                         double alpha,  
//                         double beta,   
//                         uint   lda,
//                         uint   ldb, 
//                         uint   ldc, 
//                         uint   offsetA, 
//                         uint   offsetB , 
//                         uint   offsetC 
//                       )
//
//
//
//
//


// =====  dgemm_NT_MN48.cl
static const char * dgemm_NT_48_48_8_8x8_6x6__ALPHABETA = "\
\n\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_8_8x8_6x6__ALPHABETA(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       double const beta,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
"
"\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
\n\
    uint block_k = K >> 3;\n\
    do {\n\
        __local double* plA = lA + idy*48 + 2*idx;\n\
        __local double* plB = lB + idy*48 + 2*idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        vstore2( uA.d2v[0 ], 0, plA+0  );\n\
        vstore2( uA.d2v[8 ], 0, plA+16 );\n\
        vstore2( uA.d2v[16], 0, plA+32 );\n\
        vstore2( uB.d2v[0 ], 0, plB+0  );\n\
        vstore2( uB.d2v[8 ], 0, plB+16 );\n\
        vstore2( uB.d2v[16], 0, plB+32 );\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
       \n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
"
"\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    (C[(offset_x +  0) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  0) * ldc], alpha * rC[0][0]));\n\
    (C[(offset_x +  1) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  0) * ldc], alpha * rC[0][1]));\n\
    (C[(offset_x +  0) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y +  1) * ldc], alpha * rC[1][0]));\n\
    (C[(offset_x +  1) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y +  1) * ldc], alpha * rC[1][1]));\n\
    (C[(offset_x +  0) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 16) * ldc], alpha * rC[2][0]));\n\
    (C[(offset_x +  1) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 16) * ldc], alpha * rC[2][1]));\n\
    (C[(offset_x +  0) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 17) * ldc], alpha * rC[3][0]));\n\
    (C[(offset_x +  1) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 17) * ldc], alpha * rC[3][1]));\n\
    (C[(offset_x +  0) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 32) * ldc], alpha * rC[4][0]));\n\
    (C[(offset_x +  1) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 32) * ldc], alpha * rC[4][1]));\n\
    (C[(offset_x +  0) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  0) + (offset_y + 33) * ldc], alpha * rC[5][0]));\n\
    (C[(offset_x +  1) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x +  1) + (offset_y + 33) * ldc], alpha * rC[5][1]));\n\
    (C[(offset_x + 16) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  0) * ldc], alpha * rC[0][2]));\n\
    (C[(offset_x + 17) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  0) * ldc], alpha * rC[0][3]));\n\
    (C[(offset_x + 16) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y +  1) * ldc], alpha * rC[1][2]));\n\
    (C[(offset_x + 17) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y +  1) * ldc], alpha * rC[1][3]));\n\
    (C[(offset_x + 16) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 16) * ldc], alpha * rC[2][2]));\n\
    (C[(offset_x + 17) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 16) * ldc], alpha * rC[2][3]));\n\
    (C[(offset_x + 16) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 17) * ldc], alpha * rC[3][2]));\n\
"
"\
    (C[(offset_x + 17) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 17) * ldc], alpha * rC[3][3]));\n\
    (C[(offset_x + 16) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 32) * ldc], alpha * rC[4][2]));\n\
    (C[(offset_x + 17) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 32) * ldc], alpha * rC[4][3]));\n\
    (C[(offset_x + 16) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 16) + (offset_y + 33) * ldc], alpha * rC[5][2]));\n\
    (C[(offset_x + 17) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 17) + (offset_y + 33) * ldc], alpha * rC[5][3]));\n\
    (C[(offset_x + 32) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  0) * ldc], alpha * rC[0][4]));\n\
    (C[(offset_x + 33) + (offset_y +  0) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  0) * ldc], alpha * rC[0][5]));\n\
    (C[(offset_x + 32) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y +  1) * ldc], alpha * rC[1][4]));\n\
    (C[(offset_x + 33) + (offset_y +  1) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y +  1) * ldc], alpha * rC[1][5]));\n\
    (C[(offset_x + 32) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 16) * ldc], alpha * rC[2][4]));\n\
    (C[(offset_x + 33) + (offset_y + 16) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 16) * ldc], alpha * rC[2][5]));\n\
    (C[(offset_x + 32) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 17) * ldc], alpha * rC[3][4]));\n\
    (C[(offset_x + 33) + (offset_y + 17) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 17) * ldc], alpha * rC[3][5]));\n\
    (C[(offset_x + 32) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 32) * ldc], alpha * rC[4][4]));\n\
    (C[(offset_x + 33) + (offset_y + 32) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 32) * ldc], alpha * rC[4][5]));\n\
    (C[(offset_x + 32) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 32) + (offset_y + 33) * ldc], alpha * rC[5][4]));\n\
    (C[(offset_x + 33) + (offset_y + 33) * ldc] = mad(beta, C[(offset_x + 33) + (offset_y + 33) * ldc], alpha * rC[5][5]));\n\
}\n\
\n\
\n\
";



static const char * dgemm_NT_48_48_8_8x8_6x6__ALPHA = "\
\n\
typedef union GPtr {\n\
  __global float *f;\n\
  __global double *d;\n\
  __global float2 *f2v;\n\
  __global double2 *d2v;\n\
} GPtr;\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_48_48_8_8x8_6x6__ALPHA(__global double2 const * restrict A,\n\
                                       __global double2 const * restrict B,\n\
                                       __global double * C,\n\
                                       uint const M,\n\
                                       uint const N,\n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb,\n\
                                       uint ldc,\n\
                                       uint offsetA,\n\
                                       uint offsetB,\n\
                                       uint offsetC)\n\
{\n\
    GPtr uA, uB;\n\
    uA.d2v = (__global double2 *)A;\n\
    uB.d2v = (__global double2 *)B;\n\
 //   C += offsetC;\n\
\n\
\n\
    uA.d += offsetA;\n\
    uB.d += offsetB;\n\
    C    += offsetC;\n\
\n\
\n\
    double rC[6][6] = {(double)0};\n\
    double rA[6];\n\
    double rB[6];\n\
\n\
    __local double lA[392];\n\
    __local double lB[392];\n\
\n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx  = get_local_id(0);\n\
    int idy  = get_local_id(1);\n\
\n\
\n\
    uA.d += 2*(gidx*24 + idx) + idy*lda;\n\
    uB.d += 2*(gidy*24 + idx) + idy*ldb;\n\
"
"\
\n\
    uint block_k = K >> 3;\n\
    do {\n\
        __local double* plA = lA + idy*48 + 2*idx;\n\
        __local double* plB = lB + idy*48 + 2*idx;\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        vstore2( uA.d2v[0 ], 0, plA+0  );\n\
        vstore2( uA.d2v[8 ], 0, plA+16 );\n\
        vstore2( uA.d2v[16], 0, plA+32 );\n\
        vstore2( uB.d2v[0 ], 0, plB+0  );\n\
        vstore2( uB.d2v[8 ], 0, plB+16 );\n\
        vstore2( uB.d2v[16], 0, plB+32 );\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx << 1;\n\
        int offB = idy << 1;\n\
       \n\
        #pragma unroll 1\n\
        for(uint k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0] = lA[offA +  0];\n\
            rA[1] = lA[offA +  1];\n\
            rA[2] = lA[offA + 16];\n\
            rA[3] = lA[offA + 17];\n\
            rA[4] = lA[offA + 32];\n\
            rA[5] = lA[offA + 33];\n\
            rB[0] = lB[offB +  0];\n\
            rB[1] = lB[offB +  1];\n\
            rB[2] = lB[offB + 16];\n\
            rB[3] = lB[offB + 17];\n\
            rB[4] = lB[offB + 32];\n\
            rB[5] = lB[offB + 33];\n\
            offA += 48;\n\
            offB += 48;\n\
            rC[0][0] = mad(rA[0],rB[0],rC[0][0]);\n\
            rC[0][1] = mad(rA[1],rB[0],rC[0][1]);\n\
            rC[0][2] = mad(rA[2],rB[0],rC[0][2]);\n\
            rC[0][3] = mad(rA[3],rB[0],rC[0][3]);\n\
            rC[0][4] = mad(rA[4],rB[0],rC[0][4]);\n\
            rC[0][5] = mad(rA[5],rB[0],rC[0][5]);\n\
            rC[1][0] = mad(rA[0],rB[1],rC[1][0]);\n\
            rC[1][1] = mad(rA[1],rB[1],rC[1][1]);\n\
            rC[1][2] = mad(rA[2],rB[1],rC[1][2]);\n\
            rC[1][3] = mad(rA[3],rB[1],rC[1][3]);\n\
            rC[1][4] = mad(rA[4],rB[1],rC[1][4]);\n\
            rC[1][5] = mad(rA[5],rB[1],rC[1][5]);\n\
            rC[2][0] = mad(rA[0],rB[2],rC[2][0]);\n\
            rC[2][1] = mad(rA[1],rB[2],rC[2][1]);\n\
            rC[2][2] = mad(rA[2],rB[2],rC[2][2]);\n\
            rC[2][3] = mad(rA[3],rB[2],rC[2][3]);\n\
            rC[2][4] = mad(rA[4],rB[2],rC[2][4]);\n\
"
"\
            rC[2][5] = mad(rA[5],rB[2],rC[2][5]);\n\
            rC[3][0] = mad(rA[0],rB[3],rC[3][0]);\n\
            rC[3][1] = mad(rA[1],rB[3],rC[3][1]);\n\
            rC[3][2] = mad(rA[2],rB[3],rC[3][2]);\n\
            rC[3][3] = mad(rA[3],rB[3],rC[3][3]);\n\
            rC[3][4] = mad(rA[4],rB[3],rC[3][4]);\n\
            rC[3][5] = mad(rA[5],rB[3],rC[3][5]);\n\
            rC[4][0] = mad(rA[0],rB[4],rC[4][0]);\n\
            rC[4][1] = mad(rA[1],rB[4],rC[4][1]);\n\
            rC[4][2] = mad(rA[2],rB[4],rC[4][2]);\n\
            rC[4][3] = mad(rA[3],rB[4],rC[4][3]);\n\
            rC[4][4] = mad(rA[4],rB[4],rC[4][4]);\n\
            rC[4][5] = mad(rA[5],rB[4],rC[4][5]);\n\
            rC[5][0] = mad(rA[0],rB[5],rC[5][0]);\n\
            rC[5][1] = mad(rA[1],rB[5],rC[5][1]);\n\
            rC[5][2] = mad(rA[2],rB[5],rC[5][2]);\n\
            rC[5][3] = mad(rA[3],rB[5],rC[5][3]);\n\
            rC[5][4] = mad(rA[4],rB[5],rC[5][4]);\n\
            rC[5][5] = mad(rA[5],rB[5],rC[5][5]);\n\
        }\n\
        uA.d += lda << 3;\n\
        uB.d += ldb << 3;\n\
    } while (--block_k > 0);\n\
\n\
\n\
\n\
    int offset_x = gidx*48+ idx*2;\n\
    int offset_y = gidy*48+ idy*2;\n\
    C[(offset_x +  0) + (offset_y +  0) * ldc] = alpha * rC[0][0];\n\
    C[(offset_x +  1) + (offset_y +  0) * ldc] = alpha * rC[0][1];\n\
    C[(offset_x +  0) + (offset_y +  1) * ldc] = alpha * rC[1][0];\n\
    C[(offset_x +  1) + (offset_y +  1) * ldc] = alpha * rC[1][1];\n\
    C[(offset_x +  0) + (offset_y + 16) * ldc] = alpha * rC[2][0];\n\
    C[(offset_x +  1) + (offset_y + 16) * ldc] = alpha * rC[2][1];\n\
    C[(offset_x +  0) + (offset_y + 17) * ldc] = alpha * rC[3][0];\n\
    C[(offset_x +  1) + (offset_y + 17) * ldc] = alpha * rC[3][1];\n\
    C[(offset_x +  0) + (offset_y + 32) * ldc] = alpha * rC[4][0];\n\
    C[(offset_x +  1) + (offset_y + 32) * ldc] = alpha * rC[4][1];\n\
    C[(offset_x +  0) + (offset_y + 33) * ldc] = alpha * rC[5][0];\n\
    C[(offset_x +  1) + (offset_y + 33) * ldc] = alpha * rC[5][1];\n\
    C[(offset_x + 16) + (offset_y +  0) * ldc] = alpha * rC[0][2];\n\
    C[(offset_x + 17) + (offset_y +  0) * ldc] = alpha * rC[0][3];\n\
    C[(offset_x + 16) + (offset_y +  1) * ldc] = alpha * rC[1][2];\n\
    C[(offset_x + 17) + (offset_y +  1) * ldc] = alpha * rC[1][3];\n\
    C[(offset_x + 16) + (offset_y + 16) * ldc] = alpha * rC[2][2];\n\
    C[(offset_x + 17) + (offset_y + 16) * ldc] = alpha * rC[2][3];\n\
    C[(offset_x + 16) + (offset_y + 17) * ldc] = alpha * rC[3][2];\n\
    C[(offset_x + 17) + (offset_y + 17) * ldc] = alpha * rC[3][3];\n\
    C[(offset_x + 16) + (offset_y + 32) * ldc] = alpha * rC[4][2];\n\
    C[(offset_x + 17) + (offset_y + 32) * ldc] = alpha * rC[4][3];\n\
"
"\
    C[(offset_x + 16) + (offset_y + 33) * ldc] = alpha * rC[5][2];\n\
    C[(offset_x + 17) + (offset_y + 33) * ldc] = alpha * rC[5][3];\n\
    C[(offset_x + 32) + (offset_y +  0) * ldc] = alpha * rC[0][4];\n\
    C[(offset_x + 33) + (offset_y +  0) * ldc] = alpha * rC[0][5];\n\
    C[(offset_x + 32) + (offset_y +  1) * ldc] = alpha * rC[1][4];\n\
    C[(offset_x + 33) + (offset_y +  1) * ldc] = alpha * rC[1][5];\n\
    C[(offset_x + 32) + (offset_y + 16) * ldc] = alpha * rC[2][4];\n\
    C[(offset_x + 33) + (offset_y + 16) * ldc] = alpha * rC[2][5];\n\
    C[(offset_x + 32) + (offset_y + 17) * ldc] = alpha * rC[3][4];\n\
    C[(offset_x + 33) + (offset_y + 17) * ldc] = alpha * rC[3][5];\n\
    C[(offset_x + 32) + (offset_y + 32) * ldc] = alpha * rC[4][4];\n\
    C[(offset_x + 33) + (offset_y + 32) * ldc] = alpha * rC[4][5];\n\
    C[(offset_x + 32) + (offset_y + 33) * ldc] = alpha * rC[5][4];\n\
    C[(offset_x + 33) + (offset_y + 33) * ldc] = alpha * rC[5][5];\n\
}\n\
\n\
\n\
";



static const char * dgemm_NT_32_32_8_8x8_4x4__ALPHABETA = "\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_32_32_8_8x8_4x4__ALPHABETA( __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,  \n\
                                       double const beta,   \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
    double rC[4][4]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][4];\n\
\n\
    double PreFetchA[4];\n\
    double PreFetchB[4];\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[264];\n\
    __local double lB[264];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32+ idxT + idyT*lda;\n\
    B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
    __local double* plA = lA + idyT*33+idxT;\n\
    __local double* plB = lB + idyT*33+idxT;\n\
\n\
    plA[0] = A[0];\n\
    plA[16] = A[16];\n\
    plA[132] = A[4*lda];\n\
    plA[148] = A[16+4*lda];\n\
"
"\
    plB[0] = B[0];\n\
    plB[16] = B[16];\n\
    plB[132] = B[4*ldb];\n\
    plB[148] = B[16+4*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
        //barrier(CLK_LOCAL_MEM_FENCE);\n\
        A += 8*lda;\n\
        B += 8*ldb;\n\
       \n\
       PreFetchA[0] = A[0];\n\
       PreFetchA[1] = A[16];\n\
       PreFetchA[2] = A[4*lda];\n\
       PreFetchA[3] = A[16+4*lda];\n\
       PreFetchB[0] = B[0];\n\
       PreFetchB[1] = B[16];\n\
       PreFetchB[2] = B[4*ldb];\n\
       PreFetchB[3] = B[16+4*ldb];\n\
\n\
\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
\n\
      \n\
        for( int k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
"
"\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
        }\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0]   = PreFetchA[0];\n\
        plA[16]  = PreFetchA[1];\n\
        plA[132] = PreFetchA[2];\n\
        plA[148] = PreFetchA[3];\n\
        plB[0]   = PreFetchB[0];\n\
        plB[16]  = PreFetchB[1];\n\
        plB[132] = PreFetchB[2];\n\
        plB[148] = PreFetchB[3];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      //  A += 8*lda;\n\
      //  B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
    C+=8;\n\
}\n\
";



static const char * dgemm_NT_32_32_8_8x8_4x4__ALPHA = "\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_32_32_8_8x8_4x4__ALPHA( __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,    \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
    double rC[4][4]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][4];\n\
\n\
    double PreFetchA[4];\n\
    double PreFetchB[4];\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[264];\n\
    __local double lB[264];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32+ idxT + idyT*lda;\n\
    B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
    __local double* plA = lA + idyT*33+idxT;\n\
    __local double* plB = lB + idyT*33+idxT;\n\
\n\
    plA[0] = A[0];\n\
    plA[16] = A[16];\n\
    plA[132] = A[4*lda];\n\
    plA[148] = A[16+4*lda];\n\
    plB[0] = B[0];\n\
"
"\
    plB[16] = B[16];\n\
    plB[132] = B[4*ldb];\n\
    plB[148] = B[16+4*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
        //barrier(CLK_LOCAL_MEM_FENCE);\n\
        A += 8*lda;\n\
        B += 8*ldb;\n\
       \n\
       PreFetchA[0] = A[0];\n\
       PreFetchA[1] = A[16];\n\
       PreFetchA[2] = A[4*lda];\n\
       PreFetchA[3] = A[16+4*lda];\n\
       PreFetchB[0] = B[0];\n\
       PreFetchB[1] = B[16];\n\
       PreFetchB[2] = B[4*ldb];\n\
       PreFetchB[3] = B[16+4*ldb];\n\
\n\
\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
\n\
      \n\
        for( int k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
"
"\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
        }\n\
\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0]   = PreFetchA[0];\n\
        plA[16]  = PreFetchA[1];\n\
        plA[132] = PreFetchA[2];\n\
        plA[148] = PreFetchA[3];\n\
        plB[0]   = PreFetchB[0];\n\
        plB[16]  = PreFetchB[1];\n\
        plB[132] = PreFetchB[2];\n\
        plB[148] = PreFetchB[3];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      //  A += 8*lda;\n\
      //  B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[8*ldc] = alpha*rC[0][1] ;\n\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C+=8;                     ;\n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[8*ldc] = alpha*rC[1][1] ;\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C+=8;                     ;\n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[8*ldc] = alpha*rC[2][1] ;\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C+=8;                     ;\n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[8*ldc] = alpha*rC[3][1] ;\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
    C+=8;\n\
}\n\
";





static const char * dgemm_NT_40_40_8_8x8_5x5__ALPHABETA = "\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_40_40_8_8x8_5x5__ALPHABETA( __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,  \n\
                                       double const beta,   \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
  double rC[5][5]  = {(double)0};\n\
  double rA[1][5];\n\
  double rB[1][5];\n\
\n\
  double PreFetchA[5];\n\
  double PreFetchB[5];\n\
\n\
  //double PreFetchA_5;\n\
  //double PreFetchB_5;\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[320];\n\
  __local double lB[320];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
  \n\
\n\
  A +=  gidx*40+ idxT + idyT*lda;\n\
  B +=  gidy*40+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*40+idxT;\n\
  __local double* plB = lB + idyT*40+idxT;\n\
"
"\
\n\
  \n\
\n\
    plA[0]  = A[0];\n\
    plA[8]  = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0]  = B[0];\n\
    plB[8]  = B[8];\n\
    plB[16] = B[16];\n\
    plB[24] = B[24];\n\
    plB[32] = B[32];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
/*    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
    plA[0] = A[0];\n\
    plA[8] = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0] = B[0];\n\
    plB[8] = B[8];\n\
    plB[16] = B[16];\n\
    plB[24] = B[24];\n\
    plB[32] = B[32];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
*/\n\
A += 8*lda;\n\
B += 8*ldb;\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchA[4] = A[32];\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8];\n\
    PreFetchB[2] = B[16];\n\
    PreFetchB[3] = B[24];\n\
    PreFetchB[4] = B[32];\n\
\n\
\n\
\n\
"
"\
    int offA = idx;\n\
    int offB = idy;\n\
   // int off256 = 256;\n\
\n\
\n\
#pragma unroll 1\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
\n\
\n\
      offA += 40;\n\
      offB += 40;\n\
      //off256 -= 24;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
"
"\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plA[32] = PreFetchA[4];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    plB[32] = PreFetchB[4];\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    //  A += 8*lda;\n\
    //  B += 8*ldb;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*40;\n\
  C+= idx;\n\
  C+= gidy*40*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
"
"\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
   \n\
}\n\
";




static const char * dgemm_NT_40_40_8_8x8_5x5__ALPHA = "\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_40_40_8_8x8_5x5__ALPHA( __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,\n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
  double rC[5][5]  = {(double)0};\n\
  double rA[1][5];\n\
  double rB[1][5];\n\
\n\
  double PreFetchA[5];\n\
  double PreFetchB[5];\n\
\n\
  //double PreFetchA_5;\n\
  //double PreFetchB_5;\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[320];\n\
  __local double lB[320];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
  \n\
\n\
  A +=  gidx*40+ idxT + idyT*lda;\n\
  B +=  gidy*40+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*40+idxT;\n\
  __local double* plB = lB + idyT*40+idxT;\n\
\n\
"
"\
  \n\
\n\
    plA[0]  = A[0];\n\
    plA[8]  = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0]  = B[0];\n\
    plB[8]  = B[8];\n\
    plB[16] = B[16];\n\
    plB[24] = B[24];\n\
    plB[32] = B[32];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
/*    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
    plA[0] = A[0];\n\
    plA[8] = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0] = B[0];\n\
    plB[8] = B[8];\n\
    plB[16] = B[16];\n\
    plB[24] = B[24];\n\
    plB[32] = B[32];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
*/\n\
A += 8*lda;\n\
B += 8*ldb;\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchA[4] = A[32];\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8];\n\
    PreFetchB[2] = B[16];\n\
    PreFetchB[3] = B[24];\n\
    PreFetchB[4] = B[32];\n\
\n\
\n\
\n\
    int offA = idx;\n\
"
"\
    int offB = idy;\n\
   // int off256 = 256;\n\
\n\
\n\
#pragma unroll 1\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
\n\
\n\
      offA += 40;\n\
      offB += 40;\n\
      //off256 -= 24;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
"
"\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plA[32] = PreFetchA[4];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    plB[32] = PreFetchB[4];\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    //  A += 8*lda;\n\
    //  B += 8*ldb;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*40;\n\
  C+= idx;\n\
  C+= gidy*40*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] ;\n\
  C[8*ldc] = alpha*rC[0][1] ;\n\
  C[16*ldc] = alpha*rC[0][2];\n\
  C[24*ldc] = alpha*rC[0][3];\n\
  C[32*ldc] = alpha*rC[0][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[1][0] ;\n\
  C[8*ldc] = alpha*rC[1][1] ;\n\
  C[16*ldc] = alpha*rC[1][2];\n\
  C[24*ldc] = alpha*rC[1][3];\n\
  C[32*ldc] = alpha*rC[1][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[2][0] ;\n\
  C[8*ldc] = alpha*rC[2][1] ;\n\
  C[16*ldc] = alpha*rC[2][2];\n\
  C[24*ldc] = alpha*rC[2][3];\n\
  C[32*ldc] = alpha*rC[2][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[3][0] ;\n\
  C[8*ldc] = alpha*rC[3][1] ;\n\
  C[16*ldc] = alpha*rC[3][2];\n\
  C[24*ldc] = alpha*rC[3][3];\n\
"
"\
  C[32*ldc] = alpha*rC[3][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[4][0] ;\n\
  C[8*ldc] = alpha*rC[4][1] ;\n\
  C[16*ldc] = alpha*rC[4][2];\n\
  C[24*ldc] = alpha*rC[4][3];\n\
  C[32*ldc] = alpha*rC[4][4];\n\
   \n\
}\n\
";



// ============= genericDgemm.cl
// was DgemmGenericMNK 
// M, N, K 
/// local size 8,8
//padding 32
static const char * dgemm_NT_1_1_1_8x8_4x4__ALPHABETA = "\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_1_8x8_4x4__ALPHABETA(  __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,  \n\
                                       double const beta,   \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 16;\n\
  int idyT = idt / 16;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
\n\
"
"\
    int CurrentOffSetA = gidx*32+ idxT;\n\
    int CurrentOffSetB = gidy*32+ idxT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0]   = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[16]  = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[132] = CurrentOffSetA>=M?0.0:A[4*lda];\n\
      plA[148] = CurrentOffSetA+16>=M?0.0:A[16+4*lda];\n\
     \n\
      plB[0]   = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[16]  = CurrentOffSetB+16>=N?0.0:B[16];\n\
      plB[132] = CurrentOffSetB>=N?0.0:B[4*ldb];\n\
      plB[148] = CurrentOffSetB+16>=N?0.0:B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
"
"\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0*ldc] = alpha*rC[i][0] + beta*C[0*ldc];\n\
      \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
      \n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
      \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
      \n\
\n\
    }\n\
  }\n\
  else\n\
  {\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0];\n\
      plA[16] = A[16];\n\
      plA[132] = A[4*lda];\n\
      plA[148] = A[16+4*lda];\n\
      plB[0] = B[0];\n\
      plB[16] = B[16];\n\
      plB[132] = B[4*ldb];\n\
"
"\
      plB[148] = B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      int offA = idx;\n\
      int offB = idy;\n\
     \n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
"
"\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
 \n\
  }\n\
  \n\
}\n\
\n\
"; 





static const char * dgemm_NT_1_1_1_8x8_4x4__ALPHA = "\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_1_8x8_4x4__ALPHA(  __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha, \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA,\n\
                                       uint const offsetB,\n\
                                       uint const offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 16;\n\
  int idyT = idt / 16;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
\n\
    int CurrentOffSetA = gidx*32+ idxT;\n\
"
"\
    int CurrentOffSetB = gidy*32+ idxT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0]   = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[16]  = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[132] = CurrentOffSetA>=M?0.0:A[4*lda];\n\
      plA[148] = CurrentOffSetA+16>=M?0.0:A[16+4*lda];\n\
     \n\
      plB[0]   = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[16]  = CurrentOffSetB+16>=N?0.0:B[16];\n\
      plB[132] = CurrentOffSetB>=N?0.0:B[4*ldb];\n\
      plB[148] = CurrentOffSetB+16>=N?0.0:B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
"
"\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0*ldc] = alpha*rC[i][0];\n\
      \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1];\n\
      \n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2];\n\
      \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
      \n\
\n\
    }\n\
  }\n\
  else\n\
  {\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0];\n\
      plA[16] = A[16];\n\
      plA[132] = A[4*lda];\n\
      plA[148] = A[16+4*lda];\n\
      plB[0] = B[0];\n\
      plB[16] = B[16];\n\
      plB[132] = B[4*ldb];\n\
      plB[148] = B[16+4*ldb];\n\
"
"\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      int offA = idx;\n\
      int offB = idy;\n\
     \n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
    C[0*ldc]  = alpha*rC[0][0];\n\
    C[8*ldc]  = alpha*rC[0][1];\n\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C+=8;                     \n\
"
"\
    C[0*ldc]  = alpha*rC[1][0];\n\
    C[8*ldc]  = alpha*rC[1][1];\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C+=8;                     \n\
    C[0*ldc]  = alpha*rC[2][0];\n\
    C[8*ldc]  = alpha*rC[2][1];\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C+=8;                     \n\
    C[0*ldc]  = alpha*rC[3][0];\n\
    C[8*ldc]  = alpha*rC[3][1];\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
 \n\
  }\n\
  \n\
}\n\
\n\
"; 


// was DgemmGenericMN
// M, N, K%8 
static const char * dgemm_NT_1_1_8_8x8_4x4__ALPHABETA = "\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_8_8x8_4x4__ALPHABETA(  __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha,  \n\
                                       double const beta,  \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA, \n\
                                       uint const offsetB, \n\
                                       uint const offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 16;\n\
  int idyT = idt / 16;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
\n\
"
"\
    int CurrentOffSetA = gidx*32+ idxT;\n\
    int CurrentOffSetB = gidy*32+ idxT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0]   = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[16]  = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[132] = CurrentOffSetA>=M?0.0:A[4*lda];\n\
      plA[148] = CurrentOffSetA+16>=M?0.0:A[16+4*lda];\n\
     \n\
      plB[0]   = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[16]  = CurrentOffSetB+16>=N?0.0:B[16];\n\
      plB[132] = CurrentOffSetB>=N?0.0:B[4*ldb];\n\
      plB[148] = CurrentOffSetB+16>=N?0.0:B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = 1*idx;\n\
      int offB = 1*idy;\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
"
"\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
     {\n\
      return;\n\
    }\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0*ldc] = alpha*rC[i][0] + beta*C[0*ldc];\n\
      \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
      \n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
      \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
      {\n\
        return;\n\
      }\n\
\n\
    }\n\
  }\n\
  else\n\
  {\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0];\n\
      plA[16] = A[16];\n\
      plA[132] = A[4*lda];\n\
      plA[148] = A[16+4*lda];\n\
"
"\
      plB[0] = B[0];\n\
      plB[16] = B[16];\n\
      plB[132] = B[4*ldb];\n\
      plB[148] = B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx*1;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*1*ldc;\n\
\n\
\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
"
"\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
 \n\
  }\n\
  \n\
}\n\
\n\
"; 




static const char * dgemm_NT_1_1_8_8x8_4x4__ALPHA = "\
\n\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_1_1_8_8x8_4x4__ALPHA(  __global double const * restrict A, \n\
                                       __global double const * restrict B,\n\
                                       __global double * C,  \n\
                                       uint const M, \n\
                                       uint const N, \n\
                                       uint const K,\n\
                                       double const alpha, \n\
                                       uint lda,\n\
                                       uint ldb, \n\
                                       uint ldc, \n\
                                       uint const offsetA, \n\
                                       uint const offsetB, \n\
                                       uint const offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 16;\n\
  int idyT = idt / 16;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
\n\
    int CurrentOffSetA = gidx*32+ idxT;\n\
"
"\
    int CurrentOffSetB = gidy*32+ idxT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0]   = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[16]  = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[132] = CurrentOffSetA>=M?0.0:A[4*lda];\n\
      plA[148] = CurrentOffSetA+16>=M?0.0:A[16+4*lda];\n\
     \n\
      plB[0]   = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[16]  = CurrentOffSetB+16>=N?0.0:B[16];\n\
      plB[132] = CurrentOffSetB>=N?0.0:B[4*ldb];\n\
      plB[148] = CurrentOffSetB+16>=N?0.0:B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = 1*idx;\n\
      int offB = 1*idy;\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
"
"\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
     {\n\
      return;\n\
    }\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0*ldc] = alpha*rC[i][0];\n\
      \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1];\n\
      \n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2];\n\
      \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
      {\n\
        return;\n\
      }\n\
\n\
    }\n\
  }\n\
  else\n\
  {\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0];\n\
      plA[16] = A[16];\n\
      plA[132] = A[4*lda];\n\
      plA[148] = A[16+4*lda];\n\
      plB[0] = B[0];\n\
"
"\
      plB[16] = B[16];\n\
      plB[132] = B[4*ldb];\n\
      plB[148] = B[16+4*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8*ldb;\n\
    }\n\
\n\
    C+= gidx*32;\n\
    C+= idx*1;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*1*ldc;\n\
\n\
\n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[8*ldc] = alpha*rC[0][1] ;\n\
"
"\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[8*ldc] = alpha*rC[1][1] ;\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[8*ldc] = alpha*rC[2][1] ;\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[8*ldc] = alpha*rC[3][1] ;\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
 \n\
  }\n\
  \n\
}\n\
\n\
"; 




//
// was DgemmGenericK
//
static const char * dgemm_NT_32_32_1_8x8_4x4__ALPHABETA = "\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_32_32_1_8x8_4x4__ALPHABETA(  __global double const * restrict A, \n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         double const beta,   \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB, \n\
                                         uint const offsetC)\n\
{\n\
    double rC[4][4]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][4];\n\
    \n\
    double PreFetchA[4];\n\
    double PreFetchB[4];\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[264];\n\
    __local double lB[264];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32+ idxT + idyT*lda;\n\
    B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
    __local double* plA = lA + idyT*33+1*idxT;\n\
    __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
    plA[0]   = A[0];\n\
    plA[16]  = A[16];\n\
    plA[132] = A[4*lda];\n\
"
"\
    plA[148] = A[16+4*lda];\n\
    plB[0]   = B[0];\n\
    plB[16]  = B[16];\n\
    plB[132] = B[4*ldb];\n\
    plB[148] = B[16+4*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
       // barrier(CLK_LOCAL_MEM_FENCE);\n\
        A += 8*lda;\n\
        B += 8*ldb;\n\
\n\
        PreFetchA[0] = A[0];\n\
        PreFetchA[1] = A[16];\n\
        PreFetchA[2] = A[4*lda];\n\
        PreFetchA[3] = A[16+4*lda];\n\
        PreFetchB[0] = B[0];\n\
        PreFetchB[1] = B[16];\n\
        PreFetchB[2] = B[4*ldb];\n\
        PreFetchB[3] = B[16+4*ldb];\n\
\n\
\n\
\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
\n\
      \n\
        for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
"
"\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
        }\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0]   = PreFetchA[0];\n\
        plA[16]  = PreFetchA[1];\n\
        plA[132] = PreFetchA[2];\n\
        plA[148] = PreFetchA[3];\n\
        plB[0]   = PreFetchB[0];\n\
        plB[16]  = PreFetchB[1];\n\
        plB[132] = PreFetchB[2];\n\
        plB[148] = PreFetchB[3];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
    C+=8;\n\
}\n\
\n\
";



static const char * dgemm_NT_32_32_1_8x8_4x4__ALPHA = "\
\n\
__attribute__((reqd_work_group_size(8,8,1)))\n\
__kernel void dgemm_NT_32_32_1_8x8_4x4__ALPHA(  __global double const * restrict A, \n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB, \n\
                                         uint const offsetC)\n\
{\n\
    double rC[4][4]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][4];\n\
    \n\
    double PreFetchA[4];\n\
    double PreFetchB[4];\n\
\n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[264];\n\
    __local double lB[264];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32+ idxT + idyT*lda;\n\
    B +=  gidy*32+ idxT + idyT*ldb;\n\
\n\
    __local double* plA = lA + idyT*33+1*idxT;\n\
    __local double* plB = lB + idyT*33+1*idxT;\n\
\n\
    plA[0]   = A[0];\n\
    plA[16]  = A[16];\n\
    plA[132] = A[4*lda];\n\
    plA[148] = A[16+4*lda];\n\
"
"\
    plB[0]   = B[0];\n\
    plB[16]  = B[16];\n\
    plB[132] = B[4*ldb];\n\
    plB[148] = B[16+4*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
       // barrier(CLK_LOCAL_MEM_FENCE);\n\
        A += 8*lda;\n\
        B += 8*ldb;\n\
\n\
        PreFetchA[0] = A[0];\n\
        PreFetchA[1] = A[16];\n\
        PreFetchA[2] = A[4*lda];\n\
        PreFetchA[3] = A[16+4*lda];\n\
        PreFetchB[0] = B[0];\n\
        PreFetchB[1] = B[16];\n\
        PreFetchB[2] = B[4*ldb];\n\
        PreFetchB[3] = B[16+4*ldb];\n\
\n\
\n\
\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
\n\
      \n\
        for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
"
"\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
        }\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0]   = PreFetchA[0];\n\
        plA[16]  = PreFetchA[1];\n\
        plA[132] = PreFetchA[2];\n\
        plA[148] = PreFetchA[3];\n\
        plB[0]   = PreFetchB[0];\n\
        plB[16]  = PreFetchB[1];\n\
        plB[132] = PreFetchB[2];\n\
        plB[148] = PreFetchB[3];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[8*ldc] = alpha*rC[0][1] ;\n\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[8*ldc] = alpha*rC[1][1] ;\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[8*ldc] = alpha*rC[2][1] ;\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[8*ldc] = alpha*rC[3][1] ;\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
    C+=8;\n\
}\n\
\n\
";



// ============ TNDgemmColumn.cl 

static const char * dgemm_TN_32_32_16_8x16_4x2__ALPHABETA = "\
\n\
\n\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_32_32_16_8x16_4x2__ALPHABETA( __global double const * restrict A, \n\
                                          __global double const * restrict B, \n\
                                          __global double * C,\n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha,  \n\
                                          double const beta,   \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB , \n\
                                          uint const offsetC \n\
                                          )\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    {\n\
        __local double* plA = lA + idxT*33+ idyT;\n\
        __local double* plB = lB + idxT*33+ idyT;\n\
      \n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[0+8*lda];\n\
        plA[16] = A[0+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 16];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
"
"\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    \n\
}\n\
"; 




static const char * dgemm_TN_32_32_16_8x16_4x2__ALPHA = "\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_32_32_16_8x16_4x2__ALPHA( __global double const * restrict A, \n\
                                          __global double const * restrict B, \n\
                                          __global double * C,\n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha,  \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB , \n\
                                          uint const offsetC \n\
                                          )\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    {\n\
        __local double* plA = lA + idxT*33+ idyT;\n\
        __local double* plB = lB + idxT*33+ idyT;\n\
      \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[0+8*lda];\n\
"
"\
        plA[16] = A[0+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 16];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[16*ldc] = alpha*rC[0][1];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[16*ldc] = alpha*rC[1][1];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[16*ldc] = alpha*rC[2][1];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[16*ldc] = alpha*rC[3][1];\n\
}\n\
"; 



static const char * dgemm_TN_48_48_8_8x8_6x6__ALPHABETA = "\
\n\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
__kernel void dgemm_TN_48_48_8_8x8_6x6__ALPHABETA(  __global double const * restrict A,\n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         double const beta,   \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB,\n\
                                         uint const offsetC\n\
                                         )\n\
{\n\
    double rC[6][6]  = {(double)0};\n\
    double rA[1][6];\n\
    double rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[392];\n\
    __local double lB[392];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 4;\n\
    int idyT = idt / 4;\n\
    \n\
    A +=  gidx*48*lda + idxT + idyT*lda;\n\
    B +=  gidy*48*ldb+ idxT + idyT*ldb;\n\
    \n\
    //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    uint block_k = K >> 3;\n\
    do\n\
    {\n\
        __local double* plA = lA + idxT*49+ idyT;\n\
        __local double* plB = lB + idxT*49+ idyT;\n\
   \n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0];\n\
        plA[196] = A[4];\n\
        plA[16] = A[16*lda];\n\
        plA[212] = A[4+16*lda];\n\
        plA[32] = A[32*lda];\n\
        plA[228] = A[4+32*lda];\n\
        plB[0] = B[0];\n\
        plB[196] = B[4+0*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[212] = B[4+16*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[228] = B[4+32*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rA[0][4] = lA[offA + 32];\n\
            rA[0][5] = lA[offA + 40];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            rB[0][4] = lB[offB + 32];\n\
            rB[0][5] = lB[offB + 40];\n\
            offA += 49;\n\
            offB += 49;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
"
"\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
        }\n\
        A += 8;\n\
        B += 8;\n\
    }\n\
    while (--block_k > 0);\n\
\n\
    C+= gidx*48;\n\
    C+= idx;\n\
    C+= gidy*48*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[0][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[1][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
"
"\
    C[40*ldc] = alpha*rC[2][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[3][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[4][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[5][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[5][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[5][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[5][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[5][5] + beta*C[40*ldc];\n\
    C+=8;\n\
}\n\
"; 



static const char * dgemm_TN_48_48_8_8x8_6x6__ALPHA = "\
\n\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
__kernel void dgemm_TN_48_48_8_8x8_6x6__ALPHA(  __global double const * restrict A,\n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB,\n\
                                         uint const offsetC\n\
                                         )\n\
{\n\
    double rC[6][6]  = {(double)0};\n\
    double rA[1][6];\n\
    double rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[392];\n\
    __local double lB[392];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 4;\n\
    int idyT = idt / 4;\n\
    \n\
    A +=  gidx*48*lda + idxT + idyT*lda;\n\
    B +=  gidy*48*ldb+ idxT + idyT*ldb;\n\
    \n\
    //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    uint block_k = K >> 3;\n\
    do\n\
    {\n\
        __local double* plA = lA + idxT*49+ idyT;\n\
        __local double* plB = lB + idxT*49+ idyT;\n\
   \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        plA[0] = A[0];\n\
        plA[196] = A[4];\n\
        plA[16] = A[16*lda];\n\
        plA[212] = A[4+16*lda];\n\
        plA[32] = A[32*lda];\n\
        plA[228] = A[4+32*lda];\n\
        plB[0] = B[0];\n\
        plB[196] = B[4+0*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[212] = B[4+16*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[228] = B[4+32*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 8; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rA[0][4] = lA[offA + 32];\n\
            rA[0][5] = lA[offA + 40];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            rB[0][4] = lB[offB + 32];\n\
            rB[0][5] = lB[offB + 40];\n\
            offA += 49;\n\
            offB += 49;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
"
"\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
        }\n\
        A += 8;\n\
        B += 8;\n\
    }\n\
    while (--block_k > 0);\n\
\n\
    C+= gidx*48;\n\
    C+= idx;\n\
    C+= gidy*48*ldc;\n\
    C+= idy*ldc;\n\
    \n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[8*ldc] = alpha*rC[0][1] ;\n\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C[32*ldc] = alpha*rC[0][4];\n\
    C[40*ldc] = alpha*rC[0][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
    C[8*ldc] = alpha*rC[1][1] ;\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C[32*ldc] = alpha*rC[1][4];\n\
    C[40*ldc] = alpha*rC[1][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[8*ldc] = alpha*rC[2][1] ;\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C[32*ldc] = alpha*rC[2][4];\n\
    C[40*ldc] = alpha*rC[2][5];\n\
"
"\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[8*ldc] = alpha*rC[3][1] ;\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
    C[32*ldc] = alpha*rC[3][4];\n\
    C[40*ldc] = alpha*rC[3][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[4][0] ;\n\
    C[8*ldc] = alpha*rC[4][1] ;\n\
    C[16*ldc] = alpha*rC[4][2];\n\
    C[24*ldc] = alpha*rC[4][3];\n\
    C[32*ldc] = alpha*rC[4][4];\n\
    C[40*ldc] = alpha*rC[4][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[5][0] ;\n\
    C[8*ldc] = alpha*rC[5][1] ;\n\
    C[16*ldc] = alpha*rC[5][2];\n\
    C[24*ldc] = alpha*rC[5][3];\n\
    C[32*ldc] = alpha*rC[5][4];\n\
    C[40*ldc] = alpha*rC[5][5];\n\
    \n\
}\n\
"; 




static const char * dgemm_TN_48_48_16_8x8_6x6__ALPHABETA = " \
\n\
\n\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
__kernel void dgemm_TN_48_48_16_8x8_6x6__ALPHABETA(  __global double const * restrict A, \n\
                                          __global double const * restrict B,\n\
                                          __global double * C,  \n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha,  \n\
                                          double const beta,  \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB, \n\
                                          uint const offsetC)\n\
{\n\
    double rC[6][6]  = {(double)0};\n\
    double rA[1][6];\n\
    double rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[784];\n\
    __local double lB[784];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 8;\n\
    int idyT = idt / 8;\n\
    \n\
    A +=  gidx*48*lda + idxT + idyT*lda;\n\
    B +=  gidy*48*ldb+ idxT + idyT*ldb;\n\
    \n\
    //for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    uint block_k = K >> 4;\n\
    do\n\
    {\n\
        __local double* plA = lA + idxT*49+ idyT;\n\
        __local double* plB = lB + idxT*49+ idyT;\n\
      \n\
"
"\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0+0*lda];\n\
        plA[392] = A[8+0*lda];\n\
        plA[8] = A[0+8*lda];\n\
        plA[400] = A[8+8*lda];\n\
        plA[16] = A[0+16*lda];\n\
        plA[408] = A[8+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plA[416] = A[8+24*lda];\n\
        plA[32] = A[0+32*lda];\n\
        plA[424] = A[8+32*lda];\n\
        plA[40] = A[0+40*lda];\n\
        plA[432] = A[8+40*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[392] = B[8+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[400] = B[8+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[408] = B[8+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[416] = B[8+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[424] = B[8+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
        plB[432] = B[8+40*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rA[0][4] = lA[offA + 32];\n\
            rA[0][5] = lA[offA + 40];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            rB[0][4] = lB[offB + 32];\n\
            rB[0][5] = lB[offB + 40];\n\
            offA += 49;\n\
            offB += 49;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
"
"\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    while (--block_k > 0);\n\
\n\
    C+= gidx*48;\n\
    C+= idx*1;\n\
    C+= gidy*48*ldc;\n\
    C+= idy*1*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[0][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
"
"\
    C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[1][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[2][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[3][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
    C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[4][5] + beta*C[40*ldc];\n\
    C+=8;\n\
    C[0] = alpha*rC[5][0] + beta*C[0];\n\
    C[8*ldc] = alpha*rC[5][1] + beta*C[8*ldc];\n\
    C[16*ldc] = alpha*rC[5][2] + beta*C[16*ldc];\n\
    C[24*ldc] = alpha*rC[5][3] + beta*C[24*ldc];\n\
    C[32*ldc] = alpha*rC[5][4] + beta*C[32*ldc];\n\
    C[40*ldc] = alpha*rC[5][5] + beta*C[40*ldc];\n\
    C+=8;\n\
}\n\
";




static const char * dgemm_TN_48_48_16_8x8_6x6__ALPHA = " \
\n\
\n\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
__kernel void dgemm_TN_48_48_16_8x8_6x6__ALPHA(  __global double const * restrict A, \n\
                                          __global double const * restrict B,\n\
                                          __global double * C,  \n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha, \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB, \n\
                                          uint const offsetC)\n\
{\n\
    double rC[6][6]  = {(double)0};\n\
    double rA[1][6];\n\
    double rB[1][6];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[784];\n\
    __local double lB[784];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 8;\n\
    int idyT = idt / 8;\n\
    \n\
    A +=  gidx*48*lda + idxT + idyT*lda;\n\
    B +=  gidy*48*ldb+ idxT + idyT*ldb;\n\
    \n\
    //for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    uint block_k = K >> 4;\n\
    do\n\
    {\n\
        __local double* plA = lA + idxT*49+ idyT;\n\
        __local double* plB = lB + idxT*49+ idyT;\n\
      \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
        plA[0] = A[0+0*lda];\n\
        plA[392] = A[8+0*lda];\n\
        plA[8] = A[0+8*lda];\n\
        plA[400] = A[8+8*lda];\n\
        plA[16] = A[0+16*lda];\n\
        plA[408] = A[8+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plA[416] = A[8+24*lda];\n\
        plA[32] = A[0+32*lda];\n\
        plA[424] = A[8+32*lda];\n\
        plA[40] = A[0+40*lda];\n\
        plA[432] = A[8+40*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[392] = B[8+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[400] = B[8+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[408] = B[8+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        plB[416] = B[8+24*ldb];\n\
        plB[32] = B[0+32*ldb];\n\
        plB[424] = B[8+32*ldb];\n\
        plB[40] = B[0+40*ldb];\n\
        plB[432] = B[8+40*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
       \n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rA[0][4] = lA[offA + 32];\n\
            rA[0][5] = lA[offA + 40];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 8];\n\
            rB[0][2] = lB[offB + 16];\n\
            rB[0][3] = lB[offB + 24];\n\
            rB[0][4] = lB[offB + 32];\n\
            rB[0][5] = lB[offB + 40];\n\
            offA += 49;\n\
            offB += 49;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
"
"\
            rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
            rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
            rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
            rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
            rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
            rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
            rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
            rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
            rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
            rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
            rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
            rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
            rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
            rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
            rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
            rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
            rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
            rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
            rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
            rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
            rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
            rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
            rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
            rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
            rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
            rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
            rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    while (--block_k > 0);\n\
\n\
    C+= gidx*48;\n\
    C+= idx;\n\
    C+= gidy*48*ldc;\n\
    C+= idy*ldc;\n\
\n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
    C[8*ldc] = alpha*rC[0][1] ;\n\
    C[16*ldc] = alpha*rC[0][2];\n\
    C[24*ldc] = alpha*rC[0][3];\n\
    C[32*ldc] = alpha*rC[0][4];\n\
    C[40*ldc] = alpha*rC[0][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[1][0] ;\n\
"
"\
    C[8*ldc] = alpha*rC[1][1] ;\n\
    C[16*ldc] = alpha*rC[1][2];\n\
    C[24*ldc] = alpha*rC[1][3];\n\
    C[32*ldc] = alpha*rC[1][4];\n\
    C[40*ldc] = alpha*rC[1][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[2][0] ;\n\
    C[8*ldc] = alpha*rC[2][1] ;\n\
    C[16*ldc] = alpha*rC[2][2];\n\
    C[24*ldc] = alpha*rC[2][3];\n\
    C[32*ldc] = alpha*rC[2][4];\n\
    C[40*ldc] = alpha*rC[2][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[3][0] ;\n\
    C[8*ldc] = alpha*rC[3][1] ;\n\
    C[16*ldc] = alpha*rC[3][2];\n\
    C[24*ldc] = alpha*rC[3][3];\n\
    C[32*ldc] = alpha*rC[3][4];\n\
    C[40*ldc] = alpha*rC[3][5];\n\
    C+=8;                     \n\
    C[0*ldc] = alpha*rC[4][0] ;\n\
    C[8*ldc] = alpha*rC[4][1] ;\n\
    C[16*ldc] = alpha*rC[4][2];\n\
    C[24*ldc] = alpha*rC[4][3];\n\
    C[32*ldc] = alpha*rC[4][4];\n\
    C[40*ldc] = alpha*rC[4][5];\n\
    C+=8;                     \n\
    C[0] = alpha*rC[5][0]     ;\n\
    C[8*ldc] = alpha*rC[5][1] ;\n\
    C[16*ldc] = alpha*rC[5][2];\n\
    C[24*ldc] = alpha*rC[5][3];\n\
    C[32*ldc] = alpha*rC[5][4];\n\
    C[40*ldc] = alpha*rC[5][5];\n\
    \n\
}\n\
";



static const char * dgemm_TN_1_1_1_8x16_4x2__ALPHABETA = " \
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_1_1_1_8x16_4x2__ALPHABETA(  __global double const * restrict A, \n\
                                        __global double const * restrict B,\n\
                                        __global double * C, \n\
                                        uint const M, \n\
                                        uint const N, \n\
                                        uint const K,\n\
                                        double const alpha,  \n\
                                        double const beta,\n\
                                        uint lda,\n\
                                        uint ldb, \n\
                                        uint ldc, \n\
                                        uint const offsetA, \n\
                                        uint const offsetB, \n\
                                        uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
\n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
   \n\
    __local double* plA = lA + idxT*33+ idyT;\n\
    __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
    if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
    {\n\
      int CurrentOffSetA =  idyT;\n\
      int CurrentOffSetB =  idyT;\n\
"
"\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8*lda];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24*lda];\n\
\n\
        plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8] = CurrentOffSetB+8>=N?0.0:B[8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
      }\n\
   \n\
      C+= gidx*32;\n\
      C+= idx;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*ldc;\n\
\n\
      int OffSetCM = gidx*32+idx;\n\
      int OffSetCN = gidy*32+idy;\n\
      if(OffSetCM>=M || OffSetCN>=N)\n\
        return;\n\
\n\
"
"\
      for(int i = 0; i<4; i++)\n\
      {\n\
        C[0*ldc] = alpha*rC[i][0] + beta*C[0];\n\
\n\
        if (OffSetCN+16<N)\n\
          C[16*ldc] = alpha*rC[i][1] + beta*C[16*ldc];\n\
\n\
        C+=8;\n\
        OffSetCM += 8;\n\
        if(OffSetCM>=M)\n\
          return;\n\
      }\n\
\n\
    }\n\
    else\n\
    {\n\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0];\n\
        plA[8] = A[8*lda];\n\
        plA[16] = A[16*lda];\n\
        plA[24] = A[24*lda];\n\
        plB[0] = B[0];\n\
        plB[8] = B[8*ldb];\n\
        plB[16] = B[16*ldb];\n\
        plB[24] = B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
"
"\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        \n\
        B += 16;\n\
        \n\
\n\
      }\n\
      C+= gidx*32;\n\
      C+= idx*1;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*1*ldc;\n\
      C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
      \n\
    }\n\
}\n\
"; 




static const char * dgemm_TN_1_1_1_8x16_4x2__ALPHA = " \
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_1_1_1_8x16_4x2__ALPHA(  __global double const * restrict A, \n\
                                        __global double const * restrict B,\n\
                                        __global double * C, \n\
                                        uint const M, \n\
                                        uint const N, \n\
                                        uint const K,\n\
                                        double const alpha,\n\
                                        uint lda,\n\
                                        uint ldb, \n\
                                        uint ldc, \n\
                                        uint const offsetA, \n\
                                        uint const offsetB, \n\
                                        uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
\n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
   \n\
    __local double* plA = lA + idxT*33+ idyT;\n\
    __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
    if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
    {\n\
      int CurrentOffSetA =  idyT;\n\
      int CurrentOffSetB =  idyT;\n\
\n\
"
"\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8*lda];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24*lda];\n\
\n\
        plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8] = CurrentOffSetB+8>=N?0.0:B[8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
      }\n\
   \n\
      C+= gidx*32;\n\
      C+= idx;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*ldc;\n\
\n\
      int OffSetCM = gidx*32+idx;\n\
      int OffSetCN = gidy*32+idy;\n\
      if(OffSetCM>=M || OffSetCN>=N)\n\
        return;\n\
\n\
      for(int i = 0; i<4; i++)\n\
"
"\
      {\n\
        C[0*ldc] = alpha*rC[i][0];\n\
\n\
        if (OffSetCN+16<N)\n\
          C[16*ldc] = alpha*rC[i][1];\n\
\n\
        C+=8;\n\
        OffSetCM += 8;\n\
        if(OffSetCM>=M)\n\
          return;\n\
      }\n\
\n\
    }\n\
    else\n\
    {\n\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0];\n\
        plA[8] = A[8*lda];\n\
        plA[16] = A[16*lda];\n\
        plA[24] = A[24*lda];\n\
        plB[0] = B[0];\n\
        plB[8] = B[8*ldb];\n\
        plB[16] = B[16*ldb];\n\
        plB[24] = B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        \n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
"
"\
        }\n\
        A += 16;\n\
        \n\
        B += 16;\n\
        \n\
\n\
      }\n\
      C+= gidx*32;\n\
      C+= idx;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*ldc;\n\
      C[0*ldc] = alpha*rC[0][0];\n\
      C[16*ldc] = alpha*rC[0][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[1][0];\n\
      C[16*ldc] = alpha*rC[1][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[2][0];\n\
      C[16*ldc] = alpha*rC[2][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[3][0];\n\
      C[16*ldc] = alpha*rC[3][1];\n\
      \n\
    }\n\
}\n\
"; 



static const char * dgemm_TN_1_1_16_8x16_4x2__ALPHABETA = "\
\n\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_1_1_16_8x16_4x2__ALPHABETA(  __global double const * restrict A, \n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         double const beta,   \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB, \n\
                                         uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
\n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
   \n\
    __local double* plA = lA + idxT*33+ idyT;\n\
    __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
    if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
    {\n\
      int CurrentOffSetA =  idyT;\n\
"
"\
      int CurrentOffSetB =  idyT;\n\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8*lda];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24*lda];\n\
\n\
        plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8] = CurrentOffSetB+8>=N?0.0:B[8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
      }\n\
   \n\
      C+= gidx*32;\n\
      C+= idx;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*ldc;\n\
\n\
      int OffSetCM = gidx*32+idx;\n\
      int OffSetCN = gidy*32+idy;\n\
      if(OffSetCM>=M || OffSetCN>=N)\n\
        return;\n\
"
"\
\n\
\n\
\n\
      for(int i = 0; i<4; i++)\n\
      {\n\
        C[0*ldc] = alpha*rC[i][0] + beta*C[0];\n\
\n\
        if (OffSetCN+16<N)\n\
          C[16*ldc] = alpha*rC[i][1] + beta*C[16*ldc];\n\
\n\
        C+=8;\n\
        OffSetCM += 8;\n\
        if(OffSetCM>=M)\n\
          return;\n\
      }\n\
\n\
    }\n\
    else\n\
    {\n\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0];\n\
        plA[8] = A[8*lda];\n\
        plA[16] = A[16*lda];\n\
        plA[24] = A[24*lda];\n\
        plB[0] = B[0];\n\
        plB[8] = B[8*ldb];\n\
        plB[16] = B[16*ldb];\n\
        plB[24] = B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
"
"\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
\n\
      }\n\
      C+= gidx*32;\n\
      C+= idx*1;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*1*ldc;\n\
      C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
      C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[3][0] + beta*C[0];\n\
      C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
      C+=8;\n\
    }\n\
}\n\
"; 




static const char * dgemm_TN_1_1_16_8x16_4x2__ALPHA = "\
\n\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_1_1_16_8x16_4x2__ALPHA(  __global double const * restrict A, \n\
                                         __global double const * restrict B,\n\
                                         __global double * C,  \n\
                                         uint const M, \n\
                                         uint const N, \n\
                                         uint const K,\n\
                                         double const alpha,  \n\
                                         uint lda,\n\
                                         uint ldb, \n\
                                         uint ldc, \n\
                                         uint const offsetA, \n\
                                         uint const offsetB, \n\
                                         uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C += offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
\n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
   \n\
    __local double* plA = lA + idxT*33+ idyT;\n\
    __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
    if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
    {\n\
      int CurrentOffSetA =  idyT;\n\
      int CurrentOffSetB =  idyT;\n\
"
"\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
        plA[8] = CurrentOffSetA+8>=M?0.0:A[8*lda];\n\
        plA[16] = CurrentOffSetA+16>=M?0.0:A[16*lda];\n\
        plA[24] = CurrentOffSetA+24>=M?0.0:A[24*lda];\n\
\n\
        plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
        plB[8] = CurrentOffSetB+8>=N?0.0:B[8*ldb];\n\
        plB[16] = CurrentOffSetB+16>=N?0.0:B[16*ldb];\n\
        plB[24] = CurrentOffSetB+24>=N?0.0:B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
      }\n\
   \n\
      C+= gidx*32;\n\
      C+= idx;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*ldc;\n\
\n\
      int OffSetCM = gidx*32+idx;\n\
      int OffSetCN = gidy*32+idy;\n\
      if(OffSetCM>=M || OffSetCN>=N)\n\
        return;\n\
\n\
"
"\
\n\
\n\
      for(int i = 0; i<4; i++)\n\
      {\n\
        C[0*ldc] = alpha*rC[i][0];\n\
\n\
        if (OffSetCN+16<N)\n\
          C[16*ldc] = alpha*rC[i][1];\n\
\n\
        C+=8;\n\
        OffSetCM += 8;\n\
        if(OffSetCM>=M)\n\
          return;\n\
      }\n\
\n\
    }\n\
    else\n\
    {\n\
\n\
      for( int block_k=0 ; block_k< K ; block_k+=16)\n\
      {\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0];\n\
        plA[8] = A[8*lda];\n\
        plA[16] = A[16*lda];\n\
        plA[24] = A[24*lda];\n\
        plB[0] = B[0];\n\
        plB[8] = B[8*ldb];\n\
        plB[16] = B[16*ldb];\n\
        plB[24] = B[24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        int offA = idx;\n\
        int offB = idy;\n\
\n\
        for( int k = 0 ; k < 16; k+=1)\n\
        {\n\
          rA[0][0] = lA[offA ];\n\
          rA[0][1] = lA[offA + 8];\n\
          rA[0][2] = lA[offA + 16];\n\
          rA[0][3] = lA[offA + 24];\n\
          rB[0][0] = lB[offB ];\n\
          rB[0][1] = lB[offB + 16];\n\
          offA += 33;\n\
          offB += 33;\n\
          rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
          rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
          rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
          rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
          rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
          rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
"
"\
          rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
          rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
\n\
      }\n\
      C+= gidx*32;\n\
      C+= idx*1;\n\
      C+= gidy*32*ldc;\n\
      C+= idy*1*ldc;\n\
      C[0*ldc] = alpha*rC[0][0];\n\
      C[16*ldc] = alpha*rC[0][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[1][0];\n\
      C[16*ldc] = alpha*rC[1][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[2][0];\n\
      C[16*ldc] = alpha*rC[2][1];\n\
      C+=8;\n\
      C[0*ldc] = alpha*rC[3][0];\n\
      C[16*ldc] = alpha*rC[3][1];\n\
      \n\
    }\n\
}\n\
"; 




static const char * dgemm_TN_32_32_1_8x16_4x2__ALPHABETA = "\
\n\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_32_32_1_8x16_4x2__ALPHABETA(  __global double const * restrict A, \n\
                                          __global double const * restrict B,\n\
                                          __global double * C,  \n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha,  \n\
                                          double const beta,   \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB, \n\
                                          uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    {\n\
        __local double* plA = lA + idxT*33+ idyT;\n\
        __local double* plB = lB + idxT*33+ idyT;\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0+0*lda];\n\
"
"\
        plA[8] = A[0+8*lda];\n\
        plA[16] = A[0+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
        \n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 16];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx*1;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*1*ldc;\n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[0][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[1][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[2][1] + beta*C[16*ldc];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
    C[16*ldc] = alpha*rC[3][1] + beta*C[16*ldc];\n\
    C+=8;\n\
"
"\
}\n\
\n\
"; 




static const char * dgemm_TN_32_32_1_8x16_4x2__ALPHA = "\
\n\
\n\
__attribute__( (reqd_work_group_size(8, 16, 1)) )\n\
__kernel void dgemm_TN_32_32_1_8x16_4x2__ALPHA(  __global double const * restrict A, \n\
                                          __global double const * restrict B,\n\
                                          __global double * C,  \n\
                                          uint const M, \n\
                                          uint const N, \n\
                                          uint const K,\n\
                                          double const alpha,  \n\
                                          uint lda,\n\
                                          uint ldb, \n\
                                          uint ldc, \n\
                                          uint const offsetA, \n\
                                          uint const offsetB, \n\
                                          uint const offsetC)\n\
{\n\
    double rC[4][2]  = {(double)0};\n\
    double rA[1][4];\n\
    double rB[1][2];\n\
    \n\
    \n\
    A += offsetA;\n\
    B += offsetB;\n\
    C+=offsetC;\n\
    \n\
    __local double lA[528];\n\
    __local double lB[528];\n\
    \n\
    int gidx = get_group_id(0);\n\
    int gidy = get_group_id(1);\n\
    int idx = get_local_id(0);\n\
    int idy = get_local_id(1);\n\
    \n\
    int idt = 8*idy + idx;\n\
    int idxT = idt % 16;\n\
    int idyT = idt / 16;\n\
    \n\
    A +=  gidx*32*lda + idxT + idyT*lda;\n\
    B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
    \n\
    for( int block_k=0 ; block_k< K ; block_k+=16)\n\
    {\n\
        __local double* plA = lA + idxT*33+ idyT;\n\
        __local double* plB = lB + idxT*33+ idyT;\n\
        \n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
        plA[0] = A[0+0*lda];\n\
        plA[8] = A[0+8*lda];\n\
"
"\
        plA[16] = A[0+16*lda];\n\
        plA[24] = A[0+24*lda];\n\
        plB[0] = B[0+0*ldb];\n\
        plB[8] = B[0+8*ldb];\n\
        plB[16] = B[0+16*ldb];\n\
        plB[24] = B[0+24*ldb];\n\
        barrier(CLK_LOCAL_MEM_FENCE);\n\
       \n\
        int offA = 1*idx;\n\
        int offB = 1*idy;\n\
        \n\
        for( int k = 0 ; k < min(16u, K-block_k); k+=1)\n\
        {\n\
            rA[0][0] = lA[offA + 0];\n\
            rA[0][1] = lA[offA + 8];\n\
            rA[0][2] = lA[offA + 16];\n\
            rA[0][3] = lA[offA + 24];\n\
            rB[0][0] = lB[offB + 0];\n\
            rB[0][1] = lB[offB + 16];\n\
            offA += 33;\n\
            offB += 33;\n\
            rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
            rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
            rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
            rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
            rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
            rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
            rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
            rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        }\n\
        A += 16;\n\
        B += 16;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx*1;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*1*ldc;\n\
    C[0*ldc] = alpha*rC[0][0];\n\
    C[16*ldc] = alpha*rC[0][1];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[1][0];\n\
    C[16*ldc] = alpha*rC[1][1];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[2][0];\n\
    C[16*ldc] = alpha*rC[2][1];\n\
    C+=8;\n\
    C[0*ldc] = alpha*rC[3][0];\n\
    C[16*ldc] = alpha*rC[3][1];\n\
    \n\
}\n\
"
"\
\n\
"; 



static const char * dgemm_NN_48_48_8_8x8_6x6__ALPHABETA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_48_48_8_8x8_6x6__ALPHABETA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  double const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[6][6]  = {(double)0};\n\
  double rA[1][6];\n\
  double rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
  __local double* plA = lA + idyT*49 + idxT;\n\
  __local double* plB = lB + idxT*49 + idyT;\n\
\n\
\n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
"
"\
    plA[0] = A[0+0*lda];\n\
    plA[8] = A[8+0*lda];\n\
    plA[16] = A[16+0*lda];\n\
    plA[24] = A[24+0*lda];\n\
    plA[32] = A[32+0*lda];\n\
    plA[40] = A[40+0*lda];\n\
    plB[0] = B[0+0*ldb];\n\
    plB[8] = B[0+8*ldb];\n\
    plB[16] = B[0+16*ldb];\n\
    plB[24] = B[0+24*ldb];\n\
    plB[32] = B[0+32*ldb];\n\
    plB[40] = B[0+40*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    int offA = 1*idx;\n\
    int offB = 1*idy;\n\
    \n\
    for( int k = 0 ; k < 8; k+=1){\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
      rA[0][5] = lA[offA + 40];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
      rB[0][5] = lB[offB + 40];\n\
      offA += 49;\n\
      offB += 49;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
      rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
      rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
      rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
"
"\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
      rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
      rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
      rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
      rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
      rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
      rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
      rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
      rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
    }\n\
    A += 8*lda;\n\
    B += 8;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
    C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[0][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[1][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[2][5] + beta*C[40*ldc];\n\
  C+=8;\n\
"
"\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[3][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[4][5] + beta*C[40*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[5][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[5][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[5][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[5][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[5][4] + beta*C[32*ldc];\n\
  C[40*ldc] = alpha*rC[5][5] + beta*C[40*ldc];\n\
 \n\
}\n\
\n\
";



static const char * dgemm_NN_48_48_8_8x8_6x6__ALPHA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_48_48_8_8x8_6x6__ALPHA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[6][6]  = {(double)0};\n\
  double rA[1][6];\n\
  double rB[1][6];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[392];\n\
  __local double lB[392];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*48+ idxT + idyT*lda;\n\
  B +=  gidy*48*ldb+ idx + idy*ldb;\n\
\n\
  __local double* plA = lA + idyT*49 + idxT;\n\
  __local double* plB = lB + idxT*49 + idyT;\n\
\n\
\n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0] = A[0+0*lda];\n\
"
"\
    plA[8] = A[8+0*lda];\n\
    plA[16] = A[16+0*lda];\n\
    plA[24] = A[24+0*lda];\n\
    plA[32] = A[32+0*lda];\n\
    plA[40] = A[40+0*lda];\n\
    plB[0] = B[0+0*ldb];\n\
    plB[8] = B[0+8*ldb];\n\
    plB[16] = B[0+16*ldb];\n\
    plB[24] = B[0+24*ldb];\n\
    plB[32] = B[0+32*ldb];\n\
    plB[40] = B[0+40*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
    int offA = 1*idx;\n\
    int offB = 1*idy;\n\
    \n\
    for( int k = 0 ; k < 8; k+=1){\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
      rA[0][5] = lA[offA + 40];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
      rB[0][5] = lB[offB + 40];\n\
      offA += 49;\n\
      offB += 49;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
      rC[5][0]=mad(rA[0][5],rB[0][0],rC[5][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
      rC[5][1]=mad(rA[0][5],rB[0][1],rC[5][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
      rC[5][2]=mad(rA[0][5],rB[0][2],rC[5][2]);\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
"
"\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
      rC[5][3]=mad(rA[0][5],rB[0][3],rC[5][3]);\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
      rC[5][4]=mad(rA[0][5],rB[0][4],rC[5][4]);\n\
      rC[0][5]=mad(rA[0][0],rB[0][5],rC[0][5]);\n\
      rC[1][5]=mad(rA[0][1],rB[0][5],rC[1][5]);\n\
      rC[2][5]=mad(rA[0][2],rB[0][5],rC[2][5]);\n\
      rC[3][5]=mad(rA[0][3],rB[0][5],rC[3][5]);\n\
      rC[4][5]=mad(rA[0][4],rB[0][5],rC[4][5]);\n\
      rC[5][5]=mad(rA[0][5],rB[0][5],rC[5][5]);\n\
    }\n\
    A += 8*lda;\n\
    B += 8;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*48;\n\
  C+= idx;\n\
  C+= gidy*48*ldc;\n\
  C+= idy*ldc;\n\
 \n\
    C[0*ldc] = alpha*rC[0][0] ;\n\
  C[8*ldc] = alpha*rC[0][1] ;\n\
  C[16*ldc] = alpha*rC[0][2];\n\
  C[24*ldc] = alpha*rC[0][3];\n\
  C[32*ldc] = alpha*rC[0][4];\n\
  C[40*ldc] = alpha*rC[0][5];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[1][0] ;\n\
  C[8*ldc] = alpha*rC[1][1] ;\n\
  C[16*ldc] = alpha*rC[1][2];\n\
  C[24*ldc] = alpha*rC[1][3];\n\
  C[32*ldc] = alpha*rC[1][4];\n\
  C[40*ldc] = alpha*rC[1][5];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[2][0] ;\n\
  C[8*ldc] = alpha*rC[2][1] ;\n\
  C[16*ldc] = alpha*rC[2][2];\n\
  C[24*ldc] = alpha*rC[2][3];\n\
  C[32*ldc] = alpha*rC[2][4];\n\
  C[40*ldc] = alpha*rC[2][5];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[3][0] ;\n\
"
"\
  C[8*ldc] = alpha*rC[3][1] ;\n\
  C[16*ldc] = alpha*rC[3][2];\n\
  C[24*ldc] = alpha*rC[3][3];\n\
  C[32*ldc] = alpha*rC[3][4];\n\
  C[40*ldc] = alpha*rC[3][5];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[4][0] ;\n\
  C[8*ldc] = alpha*rC[4][1] ;\n\
  C[16*ldc] = alpha*rC[4][2];\n\
  C[24*ldc] = alpha*rC[4][3];\n\
  C[32*ldc] = alpha*rC[4][4];\n\
  C[40*ldc] = alpha*rC[4][5];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[5][0] ;\n\
  C[8*ldc] = alpha*rC[5][1] ;\n\
  C[16*ldc] = alpha*rC[5][2];\n\
  C[24*ldc] = alpha*rC[5][3];\n\
  C[32*ldc] = alpha*rC[5][4];\n\
  C[40*ldc] = alpha*rC[5][5];\n\
 \n\
}\n\
\n\
";




static const char * dgemm_NN_32_32_8_8x8_4x4__ALPHABETA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_32_32_8_8x8_4x4__ALPHABETA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  double const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
  double PreFetchA[4];\n\
  double PreFetchB[4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
\n\
  __local double* plA = lA + idyT*33 + idxT;\n\
  __local double* plB = lB + idxT*33 + idyT;\n\
\n\
\n\
    plA[0] = A[0];\n\
"
"\
    plA[8] = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plB[0] = B[0];\n\
    plB[8] = B[8*ldb];\n\
    plB[16] = B[16*ldb];\n\
    plB[24] = B[24*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
  for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  {\n\
\n\
   // barrier(CLK_LOCAL_MEM_FENCE);\n\
    A += 8*lda;\n\
    B += 8;\n\
\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
\n\
   /* plA[0] = A[0+0*lda];\n\
    plA[8] = A[8+0*lda];\n\
    plA[16] = A[16+0*lda];\n\
    plA[24] = A[24+0*lda];\n\
    plB[0] = B[0+0*ldb];\n\
    plB[8] = B[0+8*ldb];\n\
    plB[16] = B[0+16*ldb];\n\
    plB[24] = B[0+24*ldb];*/\n\
   // barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    int offA = idx;\n\
    int offB = idy;\n\
\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
"
"\
      offA += 33;\n\
      offB += 33;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
   /* A += 8*lda;\n\
    B += 8;*/\n\
  }\n\
\n\
\n\
  C+= gidx*32;\n\
  C+= idx;\n\
  C+= gidy*32*ldc;\n\
  C+= idy*ldc;\n\
  \n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C+=8;\n\
"
"\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  \n\
}\n\
";




static const char * dgemm_NN_32_32_8_8x8_4x4__ALPHA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_32_32_8_8x8_4x4__ALPHA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
  double PreFetchA[4];\n\
  double PreFetchB[4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
\n\
  __local double* plA = lA + idyT*33 + idxT;\n\
  __local double* plB = lB + idxT*33 + idyT;\n\
\n\
\n\
    plA[0] = A[0];\n\
    plA[8] = A[8];\n\
"
"\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plB[0] = B[0];\n\
    plB[8] = B[8*ldb];\n\
    plB[16] = B[16*ldb];\n\
    plB[24] = B[24*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
  for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  {\n\
\n\
   // barrier(CLK_LOCAL_MEM_FENCE);\n\
    A += 8*lda;\n\
    B += 8;\n\
\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
\n\
   /* plA[0] = A[0+0*lda];\n\
    plA[8] = A[8+0*lda];\n\
    plA[16] = A[16+0*lda];\n\
    plA[24] = A[24+0*lda];\n\
    plB[0] = B[0+0*ldb];\n\
    plB[8] = B[0+8*ldb];\n\
    plB[16] = B[0+16*ldb];\n\
    plB[24] = B[0+24*ldb];*/\n\
   // barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
    int offA = idx;\n\
    int offB = idy;\n\
\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      offA += 33;\n\
"
"\
      offB += 33;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
   /* A += 8*lda;\n\
    B += 8;*/\n\
  }\n\
\n\
\n\
  C+= gidx*32;\n\
  C+= idx;\n\
  C+= gidy*32*ldc;\n\
  C+= idy*ldc;\n\
  \n\
  C[0*ldc] = alpha*rC[0][0] ;\n\
  C[8*ldc] = alpha*rC[0][1] ;\n\
  C[16*ldc] = alpha*rC[0][2];\n\
  C[24*ldc] = alpha*rC[0][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[1][0] ;\n\
  C[8*ldc] = alpha*rC[1][1] ;\n\
  C[16*ldc] = alpha*rC[1][2];\n\
  C[24*ldc] = alpha*rC[1][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[2][0] ;\n\
"
"\
  C[8*ldc] = alpha*rC[2][1] ;\n\
  C[16*ldc] = alpha*rC[2][2];\n\
  C[24*ldc] = alpha*rC[2][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[3][0] ;\n\
  C[8*ldc] = alpha*rC[3][1] ;\n\
  C[16*ldc] = alpha*rC[3][2];\n\
  C[24*ldc] = alpha*rC[3][3];\n\
  \n\
}\n\
";




static const char * dgemm_NN_1_1_8_8x8_4x4__ALPHABETA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_1_1_8_8x8_4x4__ALPHABETA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  double const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
    int CurrentOffSetA =   gidx*32 + idxT;\n\
    int CurrentOffSetB =  idyT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
"
"\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
   \n\
      plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
      plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
     \n\
      plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[8] = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
      plB[16] = CurrentOffSetB+16>=N?0.0: B[0+16*ldb];\n\
      plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
     \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
"
"\
\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0] + beta*C[0];\n\
       \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
\n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
    \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
    }\n\
  }\n\
\n\
  else\n\
  {\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0+0*lda];\n\
      plA[8] = A[8+0*lda];\n\
      plA[16] = A[16+0*lda];\n\
      plA[24] = A[24+0*lda];\n\
      plB[0] = B[0+0*ldb];\n\
      plB[8] = B[0+8*ldb];\n\
      plB[16] = B[0+16*ldb];\n\
      plB[24] = B[0+24*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
"
"\
      \n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0] + beta*C[0];\n\
      C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
      C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
      C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
      C+=8;\n\
    }\n\
  }\n\
}\n\
"
"\
";



static const char * dgemm_NN_1_1_8_8x8_4x4__ALPHA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_1_1_8_8x8_4x4__ALPHA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
    int CurrentOffSetA =   gidx*32 + idxT;\n\
    int CurrentOffSetB =  idyT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
"
"\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
   \n\
      plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
      plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
     \n\
      plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[8] = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
      plB[16] = CurrentOffSetB+16>=N?0.0: B[0+16*ldb];\n\
      plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
     \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
\n\
"
"\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0];\n\
       \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1];\n\
\n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2];\n\
    \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
    }\n\
  }\n\
\n\
  else\n\
  {\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0+0*lda];\n\
      plA[8] = A[8+0*lda];\n\
      plA[16] = A[16+0*lda];\n\
      plA[24] = A[24+0*lda];\n\
      plB[0] = B[0+0*ldb];\n\
      plB[8] = B[0+8*ldb];\n\
      plB[16] = B[0+16*ldb];\n\
      plB[24] = B[0+24*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
      \n\
"
"\
      for( int k = 0 ; k < 8; k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0];\n\
      C[8*ldc] = alpha*rC[i][1];\n\
      C[16*ldc] = alpha*rC[i][2] ;\n\
      C[24*ldc] = alpha*rC[i][3];\n\
      C+=8;\n\
    }\n\
  }\n\
}\n\
";



static const char * dgemm_NN_1_1_1_8x8_4x4__ALPHABETA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_1_1_1_8x8_4x4__ALPHABETA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  double const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
    int CurrentOffSetA =   gidx*32 + idxT;\n\
    int CurrentOffSetB =  idyT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
"
"\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
   \n\
      plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
      plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
     \n\
      plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[8] = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
      plB[16] = CurrentOffSetB+16>=N?0.0: B[0+16*ldb];\n\
      plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
     \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
"
"\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0] + beta*C[0];\n\
       \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
\n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
    \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
    }\n\
  }\n\
\n\
  else\n\
  {\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0+0*lda];\n\
      plA[8] = A[8+0*lda];\n\
      plA[16] = A[16+0*lda];\n\
      plA[24] = A[24+0*lda];\n\
      plB[0] = B[0+0*ldb];\n\
      plB[8] = B[0+8*ldb];\n\
      plB[16] = B[0+16*ldb];\n\
      plB[24] = B[0+24*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      \n\
      int offA = idx;\n\
      int offB = idy;\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
"
"\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0] + beta*C[0];\n\
      C[8*ldc] = alpha*rC[i][1] + beta*C[8*ldc];\n\
      C[16*ldc] = alpha*rC[i][2] + beta*C[16*ldc];\n\
      C[24*ldc] = alpha*rC[i][3] + beta*C[24*ldc];\n\
      C+=8;\n\
    }\n\
  }\n\
}\n\
";




static const char * dgemm_NN_1_1_1_8x8_4x4__ALPHA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_1_1_1_8x8_4x4__ALPHA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
  if(gidx==get_num_groups(0)-1 || gidy==get_num_groups(1)-1 )\n\
  {\n\
    int CurrentOffSetA =   gidx*32 + idxT;\n\
    int CurrentOffSetB =  idyT;\n\
\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
"
"\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
   \n\
      plA[0] = CurrentOffSetA>=M?0.0:A[0];\n\
      plA[8] = CurrentOffSetA+8>=M?0.0:A[8];\n\
      plA[16] = CurrentOffSetA+16>=M?0.0:A[16];\n\
      plA[24] = CurrentOffSetA+24>=M?0.0:A[24];\n\
     \n\
      plB[0] = CurrentOffSetB>=N?0.0:B[0];\n\
      plB[8] = CurrentOffSetB+8>=N?0.0:B[0+8*ldb];\n\
      plB[16] = CurrentOffSetB+16>=N?0.0: B[0+16*ldb];\n\
      plB[24] = CurrentOffSetB+24>=N?0.0:B[0+24*ldb];\n\
     \n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
     \n\
      int offA = idx;\n\
      int offB = idy;\n\
\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
    C+= gidx*32;\n\
"
"\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
    int OffSetCM = gidx*32+idx;\n\
    int OffSetCN = gidy*32+idy;\n\
    if(OffSetCM>=M || OffSetCN>=N)\n\
      return;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0];\n\
       \n\
      if (OffSetCN+8<N)\n\
        C[8*ldc] = alpha*rC[i][1];\n\
\n\
      if (OffSetCN+16<N)\n\
        C[16*ldc] = alpha*rC[i][2];\n\
    \n\
      if (OffSetCN+24<N)\n\
        C[24*ldc] = alpha*rC[i][3];\n\
\n\
      C+=8;\n\
      OffSetCM += 8;\n\
      if(OffSetCM>=M)\n\
        return;\n\
    }\n\
  }\n\
\n\
  else\n\
  {\n\
    for( int block_k=0 ; block_k< K ; block_k+=8)\n\
    {\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      plA[0] = A[0+0*lda];\n\
      plA[8] = A[8+0*lda];\n\
      plA[16] = A[16+0*lda];\n\
      plA[24] = A[24+0*lda];\n\
      plB[0] = B[0+0*ldb];\n\
      plB[8] = B[0+8*ldb];\n\
      plB[16] = B[0+16*ldb];\n\
      plB[24] = B[0+24*ldb];\n\
      barrier(CLK_LOCAL_MEM_FENCE);\n\
      \n\
      int offA = idx;\n\
      int offB = idy;\n\
      for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
      {\n\
"
"\
        rA[0][0] = lA[offA + 0];\n\
        rA[0][1] = lA[offA + 8];\n\
        rA[0][2] = lA[offA + 16];\n\
        rA[0][3] = lA[offA + 24];\n\
        rB[0][0] = lB[offB + 0];\n\
        rB[0][1] = lB[offB + 8];\n\
        rB[0][2] = lB[offB + 16];\n\
        rB[0][3] = lB[offB + 24];\n\
        offA += 33;\n\
        offB += 33;\n\
        rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
        rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
        rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
        rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
        rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
        rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
        rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
        rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
        rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
        rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
        rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
        rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
        rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
        rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
        rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
        rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      }\n\
      A += 8*lda;\n\
      B += 8;\n\
    }\n\
    C+= gidx*32;\n\
    C+= idx;\n\
    C+= gidy*32*ldc;\n\
    C+= idy*ldc;\n\
\n\
\n\
\n\
    for (int i = 0; i<4; i++)\n\
    {\n\
      C[0] = alpha*rC[i][0];\n\
      C[8*ldc] = alpha*rC[i][1];\n\
      C[16*ldc] = alpha*rC[i][2];\n\
      C[24*ldc] = alpha*rC[i][3];\n\
      C+=8;\n\
    }\n\
  }\n\
}\n\
";




static const char * dgemm_NN_32_32_1_8x8_4x4__ALPHABETA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_32_32_1_8x8_4x4__ALPHABETA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  double const beta,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
  double PreFetchA [4];\n\
  double PreFetchB [4];\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
  plA[0]  = A[0];\n\
  plA[8]  = A[8];\n\
  plA[16] = A[16];\n\
"
"\
  plA[24] = A[24];\n\
  plB[0]  = B[0];\n\
  plB[8]  = B[0+8*ldb];\n\
  plB[16] = B[0+16*ldb];\n\
  plB[24] = B[0+24*ldb];\n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  {\n\
    \n\
    //barrier(CLK_LOCAL_MEM_FENCE);\n\
    A += 8*lda;\n\
    B += 8;\n\
\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
\n\
    int offA = idx;\n\
    int offB = idy;\n\
\n\
    for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      offA += 33;\n\
      offB += 33;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
"
"\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0]; \n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
  }\n\
\n\
  C+= gidx*32;\n\
  C+= idx*1;\n\
  C+= gidy*32*ldc;\n\
  C+= idy*1*ldc;\n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C+=8;\n\
}\n\
";



static const char * dgemm_NN_32_32_1_8x8_4x4__ALPHA = "\
__attribute__( (reqd_work_group_size(8, 8, 1)) )\n\
  __kernel void dgemm_NN_32_32_1_8x8_4x4__ALPHA(__global double const * restrict A,\n\
  __global double const * restrict B,\n\
  __global double * C,\n\
  uint const M,\n\
  uint const N,\n\
  uint const K,\n\
  double const alpha,\n\
  uint lda,\n\
  uint ldb,\n\
  uint ldc,\n\
  uint offsetA,\n\
  uint offsetB,\n\
  uint offsetC)\n\
{\n\
  double rC[4][4]  = {(double)0};\n\
  double rA[1][4];\n\
  double rB[1][4];\n\
\n\
  double PreFetchA [4];\n\
  double PreFetchB [4];\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[264];\n\
  __local double lB[264];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*32+ idxT + idyT*lda;\n\
  B +=  gidy*32*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*33+1*idxT;\n\
  __local double* plB = lB + idxT*33+ idyT;\n\
\n\
\n\
  plA[0]  = A[0];\n\
  plA[8]  = A[8];\n\
  plA[16] = A[16];\n\
  plA[24] = A[24];\n\
"
"\
  plB[0]  = B[0];\n\
  plB[8]  = B[0+8*ldb];\n\
  plB[16] = B[0+16*ldb];\n\
  plB[24] = B[0+24*ldb];\n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  {\n\
    \n\
    //barrier(CLK_LOCAL_MEM_FENCE);\n\
    A += 8*lda;\n\
    B += 8;\n\
\n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
\n\
    int offA = idx;\n\
    int offB = idy;\n\
\n\
    for( int k = 0 ; k < min(8u, K-block_k); k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      offA += 33;\n\
      offB += 33;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
"
"\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0]; \n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    \n\
  }\n\
\n\
  C+= gidx*32;\n\
  C+= idx;\n\
  C+= gidy*32*ldc;\n\
  C+= idy*ldc;\n\
  C[0*ldc] = alpha*rC[0][0] ;\n\
  C[8*ldc] = alpha*rC[0][1] ;\n\
  C[16*ldc] = alpha*rC[0][2];\n\
  C[24*ldc] = alpha*rC[0][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[1][0] ;\n\
  C[8*ldc] = alpha*rC[1][1] ;\n\
  C[16*ldc] = alpha*rC[1][2];\n\
  C[24*ldc] = alpha*rC[1][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[2][0] ;\n\
  C[8*ldc] = alpha*rC[2][1] ;\n\
  C[16*ldc] = alpha*rC[2][2];\n\
  C[24*ldc] = alpha*rC[2][3];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[3][0] ;\n\
  C[8*ldc] = alpha*rC[3][1] ;\n\
  C[16*ldc] = alpha*rC[3][2];\n\
  C[24*ldc] = alpha*rC[3][3];\n\
  \n\
}\n\
";




static const char * dgemm_NN_40_40_8_8x8_5x5__ALPHABETA = "\
__attribute__((reqd_work_group_size(8,8,1)))\n\
  __kernel void dgemm_NN_40_40_8_8x8_5x5__ALPHABETA( __global double const * restrict A, \n\
  __global double const * restrict B,\n\
  __global double * C,  \n\
  uint const M, \n\
  uint const N, \n\
  uint const K,\n\
  double const alpha,  \n\
  double const beta,   \n\
  uint lda,\n\
  uint ldb, \n\
  uint ldc, \n\
  uint const offsetA,\n\
  uint const offsetB,\n\
  uint const offsetC)\n\
{\n\
  double rC[5][5]  = {(double)0};\n\
  double rA[1][5];\n\
  double rB[1][5];\n\
\n\
  double PreFetchA[5];\n\
  double PreFetchB[5];\n\
\n\
  //double PreFetchA_5;\n\
  //double PreFetchB_5;\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[320];\n\
  __local double lB[320];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*40+ idxT + idyT*lda;\n\
  B +=  gidy*40*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*40+idxT;\n\
  __local double* plB = lB + idxT*40+idyT;\n\
\n\
\n\
"
"\
  plA[0]  = A[0];\n\
  plA[8]  = A[8];\n\
  plA[16] = A[16];\n\
  plA[24] = A[24];\n\
  plA[32] = A[32]; \n\
  plB[0]  = B[0];\n\
  plB[8]  = B[8*ldb];\n\
  plB[16] = B[16*ldb];\n\
  plB[24] = B[24*ldb];\n\
  plB[32] = B[32*ldb];\n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  \n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
 /*   barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
    plA[0] = A[0];\n\
    plA[8] = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0] = B[0];\n\
    plB[8] = B[8*ldb];\n\
    plB[16] = B[16*ldb];\n\
    plB[24] = B[24*ldb];\n\
    plB[32] = B[32*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
*/\n\
\n\
    A += 8*lda;\n\
    B += 8;\n\
     \n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchA[4] = A[32]; \n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
    PreFetchB[4] = B[32*ldb];\n\
    \n\
    \n\
\n\
\n\
"
"\
\n\
    int offA = idx;\n\
    int offB = idy;\n\
   // int off256 = 256;\n\
\n\
\n\
#pragma unroll 1\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
\n\
\n\
      offA += 40;\n\
      offB += 40;\n\
     // off256 -= 24;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
"
"\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plA[32] = PreFetchA[4];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    plB[32] = PreFetchB[4];\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    //  A += 8*lda;\n\
    //  B += 8;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*40;\n\
  C+= idx;\n\
  C+= gidy*40*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[0][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[0][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[0][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[0][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[1][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[1][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[1][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[1][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[1][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[2][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[2][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[2][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[2][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[2][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[3][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[3][1] + beta*C[8*ldc];\n\
"
"\
  C[16*ldc] = alpha*rC[3][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[3][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[3][4] + beta*C[32*ldc];\n\
  C+=8;\n\
  C[0*ldc] = alpha*rC[4][0] + beta*C[0*ldc];\n\
  C[8*ldc] = alpha*rC[4][1] + beta*C[8*ldc];\n\
  C[16*ldc] = alpha*rC[4][2] + beta*C[16*ldc];\n\
  C[24*ldc] = alpha*rC[4][3] + beta*C[24*ldc];\n\
  C[32*ldc] = alpha*rC[4][4] + beta*C[32*ldc];\n\
\n\
}\n\
";




static const char * dgemm_NN_40_40_8_8x8_5x5__ALPHA = "\
__attribute__((reqd_work_group_size(8,8,1)))\n\
  __kernel void dgemm_NN_40_40_8_8x8_5x5__ALPHA( __global double const * restrict A, \n\
  __global double const * restrict B,\n\
  __global double * C,  \n\
  uint const M, \n\
  uint const N, \n\
  uint const K,\n\
  double const alpha,  \n\
  uint lda,\n\
  uint ldb, \n\
  uint ldc, \n\
  uint const offsetA,\n\
  uint const offsetB,\n\
  uint const offsetC)\n\
{\n\
  double rC[5][5]  = {(double)0};\n\
  double rA[1][5];\n\
  double rB[1][5];\n\
\n\
  double PreFetchA[5];\n\
  double PreFetchB[5];\n\
\n\
  //double PreFetchA_5;\n\
  //double PreFetchB_5;\n\
\n\
  A += offsetA;\n\
  B += offsetB;\n\
  C+=offsetC;\n\
\n\
  __local double lA[320];\n\
  __local double lB[320];\n\
\n\
  int gidx = get_group_id(0);\n\
  int gidy = get_group_id(1);\n\
  int idx = get_local_id(0);\n\
  int idy = get_local_id(1);\n\
\n\
  int idt = 8*idy + idx;\n\
  int idxT = idt % 8;\n\
  int idyT = idt / 8;\n\
\n\
  A +=  gidx*40+ idxT + idyT*lda;\n\
  B +=  gidy*40*ldb+ idxT + idyT*ldb;\n\
\n\
  __local double* plA = lA + idyT*40+idxT;\n\
  __local double* plB = lB + idxT*40+idyT;\n\
\n\
\n\
  plA[0]  = A[0];\n\
"
"\
  plA[8]  = A[8];\n\
  plA[16] = A[16];\n\
  plA[24] = A[24];\n\
  plA[32] = A[32]; \n\
  plB[0]  = B[0];\n\
  plB[8]  = B[8*ldb];\n\
  plB[16] = B[16*ldb];\n\
  plB[24] = B[24*ldb];\n\
  plB[32] = B[32*ldb];\n\
  barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
  \n\
  //for( int block_k=0 ; block_k< K ; block_k+=8)\n\
  uint block_k = K >> 3;\n\
  do\n\
  {\n\
 /*   barrier(CLK_LOCAL_MEM_FENCE);\n\
\n\
\n\
    plA[0] = A[0];\n\
    plA[8] = A[8];\n\
    plA[16] = A[16];\n\
    plA[24] = A[24];\n\
    plA[32] = A[32]; \n\
    plB[0] = B[0];\n\
    plB[8] = B[8*ldb];\n\
    plB[16] = B[16*ldb];\n\
    plB[24] = B[24*ldb];\n\
    plB[32] = B[32*ldb];\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
*/\n\
\n\
    A += 8*lda;\n\
    B += 8;\n\
     \n\
    PreFetchA[0] = A[0];\n\
    PreFetchA[1] = A[8];\n\
    PreFetchA[2] = A[16];\n\
    PreFetchA[3] = A[24];\n\
    PreFetchA[4] = A[32]; \n\
    PreFetchB[0] = B[0];\n\
    PreFetchB[1] = B[8*ldb];\n\
    PreFetchB[2] = B[16*ldb];\n\
    PreFetchB[3] = B[24*ldb];\n\
    PreFetchB[4] = B[32*ldb];\n\
    \n\
    \n\
\n\
\n\
\n\
"
"\
    int offA = idx;\n\
    int offB = idy;\n\
   // int off256 = 256;\n\
\n\
\n\
#pragma unroll 1\n\
    for( int k = 0 ; k < 8; k+=1)\n\
    {\n\
      rA[0][0] = lA[offA + 0];\n\
      rA[0][1] = lA[offA + 8];\n\
      rA[0][2] = lA[offA + 16];\n\
      rA[0][3] = lA[offA + 24];\n\
      rA[0][4] = lA[offA + 32];\n\
\n\
      rB[0][0] = lB[offB + 0];\n\
      rB[0][1] = lB[offB + 8];\n\
      rB[0][2] = lB[offB + 16];\n\
      rB[0][3] = lB[offB + 24];\n\
      rB[0][4] = lB[offB + 32];\n\
\n\
\n\
      offA += 40;\n\
      offB += 40;\n\
     // off256 -= 24;\n\
      rC[0][0]=mad(rA[0][0],rB[0][0],rC[0][0]);\n\
      rC[1][0]=mad(rA[0][1],rB[0][0],rC[1][0]);\n\
      rC[2][0]=mad(rA[0][2],rB[0][0],rC[2][0]);\n\
      rC[3][0]=mad(rA[0][3],rB[0][0],rC[3][0]);\n\
      rC[4][0]=mad(rA[0][4],rB[0][0],rC[4][0]);\n\
\n\
      rC[0][1]=mad(rA[0][0],rB[0][1],rC[0][1]);\n\
      rC[1][1]=mad(rA[0][1],rB[0][1],rC[1][1]);\n\
      rC[2][1]=mad(rA[0][2],rB[0][1],rC[2][1]);\n\
      rC[3][1]=mad(rA[0][3],rB[0][1],rC[3][1]);\n\
      rC[4][1]=mad(rA[0][4],rB[0][1],rC[4][1]);\n\
\n\
      rC[0][2]=mad(rA[0][0],rB[0][2],rC[0][2]);\n\
      rC[1][2]=mad(rA[0][1],rB[0][2],rC[1][2]);\n\
      rC[2][2]=mad(rA[0][2],rB[0][2],rC[2][2]);\n\
      rC[3][2]=mad(rA[0][3],rB[0][2],rC[3][2]);\n\
      rC[4][2]=mad(rA[0][4],rB[0][2],rC[4][2]);\n\
\n\
      rC[0][3]=mad(rA[0][0],rB[0][3],rC[0][3]);\n\
      rC[1][3]=mad(rA[0][1],rB[0][3],rC[1][3]);\n\
      rC[2][3]=mad(rA[0][2],rB[0][3],rC[2][3]);\n\
      rC[3][3]=mad(rA[0][3],rB[0][3],rC[3][3]);\n\
      rC[4][3]=mad(rA[0][4],rB[0][3],rC[4][3]);\n\
\n\
      rC[0][4]=mad(rA[0][0],rB[0][4],rC[0][4]);\n\
      rC[1][4]=mad(rA[0][1],rB[0][4],rC[1][4]);\n\
"
"\
      rC[2][4]=mad(rA[0][2],rB[0][4],rC[2][4]);\n\
      rC[3][4]=mad(rA[0][3],rB[0][4],rC[3][4]);\n\
      rC[4][4]=mad(rA[0][4],rB[0][4],rC[4][4]);\n\
\n\
    }\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    plA[0]  = PreFetchA[0];\n\
    plA[8]  = PreFetchA[1];\n\
    plA[16] = PreFetchA[2];\n\
    plA[24] = PreFetchA[3];\n\
    plA[32] = PreFetchA[4];\n\
    plB[0]  = PreFetchB[0];\n\
    plB[8]  = PreFetchB[1];\n\
    plB[16] = PreFetchB[2];\n\
    plB[24] = PreFetchB[3];\n\
    plB[32] = PreFetchB[4];\n\
\n\
    barrier(CLK_LOCAL_MEM_FENCE);\n\
    //  A += 8*lda;\n\
    //  B += 8;\n\
  }\n\
  while (--block_k > 0);\n\
\n\
  C+= gidx*40;\n\
  C+= idx;\n\
  C+= gidy*40*ldc;\n\
  C+= idy*ldc;\n\
 \n\
  C[0*ldc] = alpha*rC[0][0] ;\n\
  C[8*ldc] = alpha*rC[0][1] ;\n\
  C[16*ldc] = alpha*rC[0][2];\n\
  C[24*ldc] = alpha*rC[0][3];\n\
  C[32*ldc] = alpha*rC[0][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[1][0] ;\n\
  C[8*ldc] = alpha*rC[1][1] ;\n\
  C[16*ldc] = alpha*rC[1][2];\n\
  C[24*ldc] = alpha*rC[1][3];\n\
  C[32*ldc] = alpha*rC[1][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[2][0] ;\n\
  C[8*ldc] = alpha*rC[2][1] ;\n\
  C[16*ldc] = alpha*rC[2][2];\n\
  C[24*ldc] = alpha*rC[2][3];\n\
  C[32*ldc] = alpha*rC[2][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[3][0] ;\n\
  C[8*ldc] = alpha*rC[3][1] ;\n\
  C[16*ldc] = alpha*rC[3][2];\n\
"
"\
  C[24*ldc] = alpha*rC[3][3];\n\
  C[32*ldc] = alpha*rC[3][4];\n\
  C+=8;                     \n\
  C[0*ldc] = alpha*rC[4][0] ;\n\
  C[8*ldc] = alpha*rC[4][1] ;\n\
  C[16*ldc] = alpha*rC[4][2];\n\
  C[24*ldc] = alpha*rC[4][3];\n\
  C[32*ldc] = alpha*rC[4][4];\n\
\n\
}\n\
";


